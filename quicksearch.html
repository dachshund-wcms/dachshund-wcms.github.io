<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"component_lib_Component.js.html":{"id":"component_lib_Component.js.html","title":"Source: component/lib/Component.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: component/lib/Component.js 'use strict'; const Q = require('q'); const logger = require('dachshund-logger').getLogger(__filename); const assert = require('assert'); const componentScriptHandler = require('component-script-handler'); class Component { /** * A component is a bundle of data, logic and request information to process it and return the result in the response * * @param {ClientRequest} req * @param {ServerResponse} res * @param {RequestPathInfo} pathInfo * @param {Resource} contentResource - the content resource which contains the data to be procssed * @param {Resource} componentResource - the component resource which which contains the logic to process the data */ constructor(req, res, pathInfo, contentResource, componentResource) { /** * @type {ClientRequest} */ this.req = req; /** * @type {ServerResponse} */ this.res = res; /** * @type {RepositorySession} */ this.session = req.session; /** * @type {RequestPathInfo} */ this.pathInfo = pathInfo; /** * The content resource which is assigned to be processed whith this component * @type {Resource} */ this.resource = contentResource; /** * The component resource which is defined on the property {@link Component.resource.properties.componentPath} and which is aimed to process the content resource * @type {Resource} */ this.componentResource = componentResource; /** * Parent component of this component * @type {Component} */ this.superComponent = null; }; /** * Executes a script from the {@link Component.componentResource} or {@link Component.superComponent} * @param {string} scriptName - name of the script which shall be executed from {@link Component.componentResource} * @param {string} [scriptExtension] - file extension of the script * @param {Object[]} [parameter] - additional parameters which are passed on to the script handler * @returns {promise} resolves when the script is handled */ executeScript(scriptName, scriptExtension, parameter) { let deferred = Q.defer(); let self = this; let scriptPath = scriptName; const handleScript = function(scriptPath, parameter) { assert(scriptPath != null, &quot;There is no script with the name '&quot; + scriptName + &quot;' within this or the parent components.&quot;); let scriptExtension = scriptPath.lastSubstringAfter(&quot;.&quot;); let scriptHandler = componentScriptHandler.getScriptHandler(scriptPath.lastSubstringAfter(&quot;.&quot;)); assert(scriptHandler != undefined, &quot;Script handler for extension '&quot; + scriptExtension + &quot;'&quot;); logger.trace(&quot;Execute script [&quot; + scriptPath + &quot;] with scriptHandler [&quot; + scriptHandler.extension + &quot;]&quot;); Q(scriptHandler.handle(self, scriptPath, parameter)).then(deferred.resolve).fail(deferred.reject); }; if (scriptName != null &amp;&amp; !scriptName.startsWith(&quot;/&quot;)) { this.resolveScript(scriptName, true, scriptExtension).then(function(scriptPath) { handleScript(scriptPath, parameter); }).fail(deferred.reject); } else { handleScript(scriptPath, parameter); } return deferred.promise; }; /** * Look up the default script of the component. The default script matches with name of the component. * @returns {promise} resolves the path {@link string} of the script inside the context of the application server */ getDefaultScript() { let deferred = Q.defer(); let self = this; this.resolveScript(self.componentResource.name, false).then(deferred.resolve).fail(function() { if (self.superComponent != null) { self.superComponent.getDefaultScript().then(deferred.resolve).fail(deferred.reject); } else { deferred.reject(); } }); return deferred.promise; }; /** * Resolves script file from {@link Component.componentResource} or recursive from {@link Component.superComponent.componentResource} * @param {string} scriptName - name of the script which shall be executed from {@link Component.componentResource} * @param recursive {boolean} - true: if the script cannot be resolved in the {@link Component.componentResource} the search is continued with the {@link Component.superComponent}; false: the lookup is limited to the {@link Component.componentResource} see true case * @param {string} [extension] - file extension of the script * @returns {promise} resolves the path of the script {@link string} inside the context of the application server */ resolveScript(scriptName, recursive, extension) { let deferred = Q.defer(); let self = this; self.componentResource.getFiles().then(function(componentResourceFiles) { let scriptPath = null; componentResourceFiles.forEach(function(componentResourceFile) { let scriptNameMatch = componentResourceFile.lastSubstringBefore(&quot;.&quot;) == scriptName; let isNotATemporaryFile = !componentResourceFile.endsWith(&quot;~&quot;); let extensionMatch = (extension == undefined || componentResourceFile.lastSubstringAfter(&quot;.&quot;) == extension); if (scriptNameMatch &amp;&amp; extensionMatch &amp;&amp; isNotATemporaryFile) { scriptPath = self.componentResource.path + &quot;/&quot; + componentResourceFile; } }); if (recursive == undefined) { recursive = true; } if (recursive &amp;&amp; scriptPath == null &amp;&amp; self.superComponent != null) { self.superComponent.resolveScript(scriptName, recursive, extension).then(deferred.resolve).fail(deferred.reject); } else if (scriptPath != undefined || scriptPath != null) { deferred.resolve(scriptPath); } else { deferred.reject(new Error(&quot;No matching script found with script name [&quot; + scriptName + &quot;], extension [&quot; + extension + &quot;] recursive execution [&quot; + recursive + &quot;] for component [&quot; + self.path + &quot;]&quot;)); } }).fail(deferred.reject); return deferred.promise; }; } module.exports = Component; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"dachshund-error_lib_DachshundError.js.html":{"id":"dachshund-error_lib_DachshundError.js.html","title":"Source: dachshund-error/lib/DachshundError.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: dachshund-error/lib/DachshundError.js class DachshundError extends Error { /** * Extended version of the standard {@link Error} to store more information of an error * * @param {string} [message] - Describing error message * @param {number} id - ID of the error, to distinguish errors by their identifier * @param {DachshundError|Error} nestedError - nested error which is encapbsulated in this error * * @example * * //Init promise * const Q = require('q'); * * someFailingFunction() { * * let deferred = Q.defer(); * * let originError = new Error('The dog has eaten all the food'); * * // Can be returned by a promise * deferred.reject(new DachshundError('No dog food left', 404, originError)); * * // or can be thrown in an exception * throw(new DachshundError('No dog food left', 404, originError)); * * return deferred.promise; * * } */ constructor(message, id, nestedError) { this.message = &quot;undefined error&quot;; this.id = -1; this.nestedError = null; if (typeof(message) == 'string' || message instanceof String) { this.message = message; Error.call(this, message); } else if (!isNaN(message)) { this.id = message; } else if (message instanceof Error) { this.nestedError = message; } if (!isNaN(id)) { this.id = id; } else if (id instanceof Error) { this.nestedError = id; } if (nestedError instanceof Error) { this.nestedError = nestedError; } } toString() { var errorMessage = &quot;&quot;; if (typeof(this.message) == 'string' || this.message instanceof String) { errorMessage += this.message; } if (this.nestedError != undefined &amp;&amp; this.nestedError != null) { errorMessage += &quot;\\n\\t&quot; + this.nestedError.toString(); } return errorMessage; }; get stack() { return this.nestedError != undefined ? this.nestedError.stack : &quot;\\t ... unkndown ...&quot;; } } module.exports = DachshundError; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"local-resource_lib_localResource.js.html":{"id":"local-resource_lib_localResource.js.html","title":"Source: local-resource/lib/localResource.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: local-resource/lib/localResource.js 'use strict'; const Resource = require('resource'); const ResourceTypes = require('resource-types'); const fs = require('fs'); const assert = require('assert'); const nodeProperties = require('./nodeProperties.js'); const nodeAuthorization = require(&quot;./nodeAuthorization.js&quot;); const Q = require('q'); const repositoryManager = require('repository-manager'); /** * The local resource represents a resource which is held in the local file systen. The physical element of a resource * is a folder in the file system. The files '.properties.json' and 'auth.json' contain the properties and authorization * information of the resource. It provides access to the child resources through the held sub-folders. The parent * resource is the parent folder. The files in this folders can be access and modified as well. * @class * @extends Resource */ class LocalResource extends Resource { /** * @inheritDoc */ getFiles(includeHiddenFiles) { let deferred = Q.defer(); if (includeHiddenFiles == undefined) { includeHiddenFiles == false; } let resourceFiles = this._resourceFiles; if (resourceFiles == null &amp;&amp; this.type == ResourceTypes.RESOURCE) { resourceFiles = []; let path = this.path; fs.readdirSync(&quot;.&quot; + path).forEach(function(file) { if (fs.statSync(&quot;.&quot; + path + &quot;/&quot; + file).isFile() &amp;&amp; (includeHiddenFiles || !file.startsWith(&quot;.&quot;))) { resourceFiles.push(file); } }); this._resourceFiles = resourceFiles; } deferred.resolve(resourceFiles); return deferred.promise; } /** * @inheritDoc */ fileExists(filename) { let deferred = Q.defer(); const includeHiddenFiles = true; this.getFiles(includeHiddenFiles).then(function(files) { deferred.resolve(files.indexOf(filename) != -1); }).fail(deferred.reject); return deferred.promise; } /** * @inheritDoc */ deleteFile(filename) { let self = this; let deferred = Q.defer(); this.fileExists(filename).then(function(fileExists) { if (fileExists) { let filePath = &quot;.&quot; + self.path + &quot;/&quot; + filename; Q.nfcall(fs.unlink, filePath).then(function() { self._resourceFiles = null; deferred.resolve(); }).fail(deferred.reject); } else { deferred.reject(new Error(&quot;File [&quot; + filename + &quot;] doesn't exist.&quot;)); } }).fail(deferred.reject); return deferred.promise; } /** * @inheritDoc */ deleteAllFiles(includeHiddenFiles) { let self = this; let deferred = Q.defer(); let includeHidden = includeHiddenFiles || false; this.getFiles(includeHidden).then(function(fileList) { let deleteFilesPromises = []; fileList.forEach(function(fileName) { deleteFilesPromises.push(self.deleteFile(fileName)); }); Q.allSettled(deleteFilesPromises).then(function() { deferred.resolve(self); }).fail(deferred.reject); }).fail(deferred.reject); return deferred.promise; } /** * @inheritDoc */ addFile(sourceReadStream, filename) { let deferred = Q.defer(); let destinationPath = &quot;.&quot; + this.path + &quot;/&quot; + filename; let destinationFile = fs.createWriteStream(destinationPath); destinationFile.on('finish', deferred.resolve).on('error', deferred.reject); sourceReadStream.pipe(destinationFile); return deferred.promise; } /** * @inheritDoc */ loadScript(scriptName) { let deferred = Q.defer(); let self = this; this.fileExists(scriptName).then(function(fileExists) { if (!fileExists) { deferred.reject(new Error(&quot;Script '&quot; + self.path + &quot;/&quot; + scriptName + &quot;' doesn't exist.&quot;)); } else { try { let resolvedScript = require(process.cwd() + self.path + &quot;/&quot; + scriptName); deferred.resolve(resolvedScript); } catch (err) { deferred.reject(err); } } }).fail(deferred.reject); return deferred.promise; } /** * @inheritDoc */ getChilds() { let deferred = Q.defer(); let resourceChilds = this._resourceChilds || []; if (this.type == ResourceTypes.RESOURCE) { resourceChilds = []; let path = this.path; fs.readdirSync(&quot;.&quot; + path).forEach(function(file) { if (fs.statSync(&quot;.&quot; + path + &quot;/&quot; + file).isDirectory() &amp;&amp; !file.startsWith(&quot;.&quot;)) { resourceChilds.push(file); } }); this._resourceChilds = resourceChilds; } deferred.resolve(resourceChilds); return deferred.promise; } /** * @inheritDoc */ getChildResources() { let deferred = Q.defer(); let self = this; this.getChilds().then(function(childNames) { if (childNames.length == 0) { deferred.resolve([]); if (cb instanceof Function) { cb([]); } } let childResourcePromises = []; childNames.forEach(function(childName) { let childResourcePath = self.path + &quot;/&quot; + childName; childResourcePromises.push(repositoryManager.resolve(childResourcePath)); }); Q.all(childResourcePromises).then(function(childResources) { deferred.resolve(childResources); }).fail(deferred.reject) }); return deferred.promise; } /** * @inheritDoc */ getParentResource() { let deferred = Q.defer(); let parentPath = this.path.lastSubstringBefore(&quot;/&quot;); if (parentPath.length &gt; 0) { repositoryManager.resolve(parentPath).then(function(parentResource) { deferred.resolve(parentResource); }).fail(deferred.reject); } else { deferred.resolve(null); } return deferred.promise; } /** * @inheritDoc */ getAbsoluteParentResource(depth) { assert(!isNaN(depth), &quot;It is expected that the paramater [depth] is a number.&quot;); assert(depth &gt;= 0, &quot;It is expected that the parameter [depth] is greater or equal than zero.&quot;); let deferred = Q.defer(); depth += 1; if (this.depth &lt; depth) { deferred.reject(new Error(&quot;The request depth [&quot; + depth + &quot;] can't be resolved from [&quot; + this.path + &quot;]&quot;)); } else if (this.depth == depth) { deferred.resolve(this); } else { let sourcePathFragments = this.path.split(&quot;/&quot;); let destinationPathFragments = sourcePathFragments.slice(0, depth); let destinationPath = destinationPathFragments.join(&quot;/&quot;); repositoryManager.resolve(destinationPath).then(deferred.resolve).fail(deferred.reject); } return deferred.promise; } /** * @inheritDoc */ getHiddenResourceChilds() { let deferred = Q.defer(); let resourceChilds = this._resourceChilds; if (resourceChilds == null &amp;&amp; this.type == resourceTypes.RESOURCE) { resourceChilds = []; let path = this.path; fs.readdirSync(&quot;.&quot; + path).forEach(function(file) { if (fs.statSync(&quot;.&quot; + path + &quot;/&quot; + file).isDirectory() &amp;&amp; file.startsWith(&quot;.&quot;)) { resourceChilds.push(file); } }); this._resourceChilds = resourceChilds; } deferred.resolve(resourceChilds); return deferred.promise; } /** * @inheritDoc */ loadProperties() { let deferred = Q.defer(); this.properties = nodeProperties.load(this.path); deferred.resolve(this); return deferred.promise; } /** * @inheritDoc */ saveProperties() { let self = this; let deferred = Q.defer(); this.properties.id = this.properties.id || this.id; nodeProperties.save(this.path, this.properties); this.properties.id = undefined; deferred.resolve(self); return deferred.promise; } /** * @inheritDoc */ loadAuthorization() { let deferred = Q.defer(); this.auth = nodeAuthorization.load(this.path); deferred.resolve(this); return deferred.promise; } /** * @inheritDoc */ saveAuthorization() { let deferred = Q.defer(); nodeAuthorization.save(this.path, this.auth); deferred.resolve(this); return deferred.promise; } } module.exports = LocalResource; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"resource_lib_resource.js.html":{"id":"resource_lib_resource.js.html","title":"Source: resource/lib/resource.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: resource/lib/resource.js 'use strict'; const stringUtils = require('string-utils'); const ResourceTypes = require('resource-types'); const Q = require('q'); class Resource { /** * Resource is an element of hierarchical structure. It has one parent resource and may have multiple child * resources. Furthermore a resource can contain files and properties which can be accessed or modified. The ID * of each resource is represented by it's path and can be referenced trough it. */ constructor() { this.name = null; this.path = null; this.properties = null; this.auth = null; this.type = ResourceTypes.NOT_FOUND; this._resourceFiles = null; } /** * The level on which the path of the resource is located * * - The root node has the depth of 0 * - The first level of child nodes has the depth 1 * - The path '/path/to/my/resource' has the depth 4 * * @returns {number} the depth of this resource as a integer */ get depth() { let resourceDepth = 0; if (stringUtils.isNotEmpty(this.path)) { resourceDepth = this.path.split(&quot;/&quot;).length; } return resourceDepth; } /** * Reads a property which belong to the resource * @param {String} name name of the property which shall be read * @param {*} [defaultValue] will be return in the case that the property isn't defined * @returns {*} the value of the property or the default value when it's defined and the property isn't set */ getProperty(name, defaultValue) { let value = defaultValue; if (this.properties[name] != undefined) { value = this.properties[name]; } return value; } /** * Provides a list of files which belong to this resource * @param {boolean} [includeHiddenFiles] - true: hidden files, starting with a dot (e.g. '.hiddenFile') will be included; false - otherwise (default) * @returns {promise} resolves with a list of files {@link string[]} which belong to this resource */ getFiles(includeHiddenFiles) { return Q([]); } /** * Checks weather a files exists or not * @param filename - name of the file to be checked * @returns {promise} resolves with {@link true} when the file exists and {@link false} otherwise */ fileExists(filename) { return Q(false); } /** * Checks weather a file exists or not and deletes it in case it exists * @param filename - name of the file to be deleted * @returns {promise} resolves with {@link true} when the file existed and is deleted; {@link false} when the file didn't existed */ deleteFile(filename) { return Q(false); } /** * Deletes all files from this resource * @param includeHiddenFiles [includeHiddenFiles] - true: hidden files, starting with a dot (e.g. '.hiddenFile') will be included; false - otherwise (default) * @returns {promise} */ deleteAllFiles(includeHiddenFiles) { return Q(false); } /** * Adds a file to the resource * @param sourceReadStream - stream to fill the file content * @param filename - sets the name of the file * @returns {promise} resolves when the file is added to the resource */ addFile(sourceReadStream, filename) { return Q(); } /** * Loads a script from the resource with the node.js require method * @param scriptName - name of the script to loaded * @returns {promise} resolves with the loaded script */ loadScript(scriptName) { return Q(); } /** * Provides a list of childs belonging to this resource * @returns {promise} resolves with a list {@link string[]} of childs belonging to this resource */ getChilds() { return Q([]); } /** * Provides a list of childs resources belonging to this resource * @returns {promise} resolves with a list {@link Resource[]} of child resources belonging to this resource */ getChildResources() { return Q([]); } /** * Provides the parent resource of this resource * @returns {promise} resolves with the {@link Resource} which represents the parent of this resource */ getParentResource() { return Q(new Resource()); } /** * Provides an absolute parent of this resource * @param {number} depth - number of depth of the requested parent resource; the number has be greate then 0 and smaller then it's own depth * @returns {promise} resolves with the {@link Resource} which represents the absolute parent of this resource */ getAbsoluteParentResource(depth) { return Q(new Resource()); } /** * Provides a list of all hidden child nodes represented as a {@link Resource}. To be a hidden child node the * child node name has to start with a dot (e.g. '.hiddenChildNode') * @returns {promise} resolves with a list {@link Resource[]} of child resources belonging to this resource */ getHiddenResourceChilds() { return Q([]); } /** * Loads ths properties of this resource which can be access through the member {@link properties} * @returns {promise} resolves when the properties are loaded */ loadProperties() { return Q(this.properties); } /** * Persists changes which were made to the class member {@link properties} * @returns {promise} resolves when the properties are saved */ saveProperties() { return Q(); } /** * Loads the authorization properties which define the access rights to this resource. * @returns {promise} resolves when the authorization properties are loaded */ loadAuthorization() { return Q(this.auth); } /** * Persists changes which were made to the class member {@link auth} * @returns {promise} resolves when the authorization properties are saved */ saveAuthorization() { return Q(); } /** * Provides the data of this resource * @returns {{name: string, path: string, depth: number, properties: Object, auth: Object}} */ getData() { return { name: this.name, path: this.path, depth: this.depth, properties: this.properties, auth: this.auth } } } module.exports = Resource; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"authentication-handler-basic-auth_lib_authenticationHandlerBasicAuth.js.html":{"id":"authentication-handler-basic-auth_lib_authenticationHandlerBasicAuth.js.html","title":"Source: authentication-handler-basic-auth/lib/authenticationHandlerBasicAuth.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: authentication-handler-basic-auth/lib/authenticationHandlerBasicAuth.js /** @module authentication-handler-basic-auth */ 'use strict'; const userManager = require('user-manager'); const sessionManager = require('user-session-manager'); const RepositorySession = require('repository-session'); const Q = require('q'); const config = require('config'); const allowAnonymousUser = config.get('user.session.allowAnonymousUser'); const basicAuthenticationHandler = exports; /** * Extract basic authentication header from http request object * @param {Object} req http request object * @returns {{username: *, password: *}} */ const extractCredentials = function(req) { let header = req.headers['authorization'] || '', // get the header token = header.split(/\\s+/).pop() || '', // and the encoded auth token auth = new Buffer(token, 'base64').toString(), // convert from base64 parts = auth.split(/:/), // split on colon username = parts[0], password = parts[1]; return { username: username, password: password } }; basicAuthenticationHandler.extractCredentials = extractCredentials; /** * Checks weather the authorization header is set in the http request * @param req http request object * @returns {boolean} true - when header is set | false - otherwise */ const authenticationHeaderIsSet = function(req) { return req.headers['authorization'] != undefined; }; basicAuthenticationHandler.authenticationHeaderIsSet = authenticationHeaderIsSet; basicAuthenticationHandler.checkAndAuthenticateUser = function(req, res) { let deferred = Q.defer(); let proceedRequest = false; if (authenticationHeaderIsSet(req) &amp;&amp; req.userSession.isAnonymous) { let credentials = extractCredentials(req); userManager.authenticate(credentials.username, credentials.password, function(userResource) { if (userResource != null) { sessionManager.createSession(req, res, userResource).then(function(userSession) { req.userSession = userSession; req.session = new RepositorySession(userSession); proceedRequest = true; deferred.resolve(proceedRequest); }); } else { deferred.resolve(proceedRequest); } }); } else { deferred.resolve(allowAnonymousUser); } return deferred.promise; }; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"component-handler_lib_componentHandler.js.html":{"id":"component-handler_lib_componentHandler.js.html","title":"Source: component-handler/lib/componentHandler.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: component-handler/lib/componentHandler.js /** @module component-handler/componentHandler */ 'use strict'; const Q = require('q'); const componentHandler = exports; const logger = require('dachshund-logger').getLogger(__filename); const prepareScriptHandler = require('./prepareScriptHandler.js'); /** * Processes the component by looking up the script which is matches to the request and to execute the script * @param component {Component} The component to be handled with the enclosed request information * @returns {promise} resolved when a script could be resolved and executed * @alias module:component-handler/componentHandler.handle */ componentHandler.handle = function(component) { let deferred = Q.defer(); prepareScriptHandler.resolveAndHandle(component).then(function() { // Lookup script based on the component return componentHandler.getScriptToHandle(component); }).then(function(scriptPath) { logger.trace(&quot;Script [&quot; + scriptPath + &quot;] found for component [&quot; + component.componentResource.path + &quot;]&quot; + getPathinfoString(component)); component.executeScript(scriptPath).then(deferred.resolve).fail(deferred.reject); }).fail(function() { // Was the first attempt not successful, it will be retried with the component resource name as prefix componentHandler.getScriptToHandle(component, component.componentResource.name).then(function(scriptPath) { logger.trace(&quot;Script [&quot; + scriptPath + &quot;] found for component [&quot; + component.componentResource.path + &quot;] with name [&quot; + component.componentResource.name + &quot;]&quot; + getPathinfoString(component)); component.executeScript(scriptPath).then(deferred.resolve).fail(deferred.reject); }).fail(function() { // Were both attempts to lookup a script not successful, a third lookup is execute to // lookup a script which is called as the comp component.getDefaultScript().then(function(scriptPath) { logger.trace(&quot;Default script [&quot; + scriptPath + &quot;] found for component [&quot; + component.componentResource.path + &quot;]&quot; + getPathinfoString(component)); component.executeScript(scriptPath).then(deferred.resolve).fail(deferred.reject); }).fail(function() { deferred.reject(new Error(&quot;No matching script can be found in this component [&quot; + component.componentResource.path + &quot;]&quot; + getPathinfoString(component))); }); }) }); return deferred.promise; }; /** * Lookup a matching script which is able to handle the request with the speicifed selector and extension in the {@link RequestPathInfo} * @param {Component} component - with the enclosed request information * @param {string} prefix - will be set in front of the script file name to resolve a possible match * @returns {promise} which resolves with the scriptPath {string} * @alias module:component-handler/componentHandler.getScriptToHandle */ componentHandler.getScriptToHandle = function(component, prefix) { let deferred = Q.defer(); if (prefix == undefined) { prefix = &quot;&quot;; } else { prefix = prefix + &quot;.&quot;; } resolveScriptByMethodSelectorAndExtension(component, prefix).then(function(scriptPath) { deferred.resolve(scriptPath); }).fail(function() { return resolveScriptBySelector(component, prefix); }).then(function(scriptPath) { deferred.resolve(scriptPath); }).fail(function() { resolverScriptByExtension(component, prefix).then(function(scriptPath) { deferred.resolve(scriptPath); }).fail(function() { resolveScriptByMethodName(component, prefix).then(function(scriptPath) { deferred.resolve(scriptPath); }).fail(function() { deferred.reject(new Error(&quot;No script found for component: &quot; + component.componentResource.path)); }); }); }); return deferred.promise; }; const resolveScriptByMethodName = function(component, prefix) { let deferred = Q.defer(); let scriptName = prefix + component.pathInfo.method; component.resolveScript(scriptName).then(deferred.resolve).fail(deferred.reject); return deferred.promise; }; const resolverScriptByExtension = function(component, prefix) { let deferred = Q.defer(); if (component.pathInfo.method == &quot;GET&quot; &amp;&amp; component.pathInfo.selector != null) { let scriptName = prefix + component.pathInfo.extension; component.resolveScript(scriptName).then(deferred.resolve).fail(deferred.reject); } else { deferred.reject(); } return deferred.promise; }; const resolveScriptBySelector = function(component, prefix) { let deferred = Q.defer(); if (component.pathInfo.method == &quot;GET&quot; &amp;&amp; component.pathInfo.selector != null) { let scriptName = prefix + component.pathInfo.selector; component.resolveScript(scriptName).then(deferred.resolve).fail(deferred.reject); } else { deferred.reject(); } return deferred.promise; }; const resolveScriptByMethodSelectorAndExtension = function(component, prefix) { let deferred = Q.defer(); let scriptName = &quot;&quot;; if (component.pathInfo.method == &quot;GET&quot; &amp;&amp; component.pathInfo.selector == null) { scriptName = prefix + component.pathInfo.extension; } else if (component.pathInfo.method == &quot;GET&quot; &amp;&amp; component.pathInfo.selector != null) { scriptName = prefix + component.pathInfo.selector + &quot;.&quot; + component.pathInfo.extension; } else if (component.pathInfo.selector == null) { scriptName = prefix + component.pathInfo.method + &quot;.&quot; + component.pathInfo.extension; } else if (component.pathInfo.selector != null) { scriptName = prefix + component.pathInfo.method + &quot;.&quot; + component.pathInfo.selector + &quot;.&quot; + component.pathInfo.extension; } component.resolveScript(scriptName).then(deferred.resolve).fail(deferred.reject); return deferred.promise; }; const getPathinfoString = function(component) { return &quot; request method [&quot; + component.pathInfo.method + &quot;] selector [&quot; + component.pathInfo.selector + &quot;] extension [&quot; + component.pathInfo.extension + &quot;]&quot;; }; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"component-handler_lib_componentLoader.js.html":{"id":"component-handler_lib_componentLoader.js.html","title":"Source: component-handler/lib/componentLoader.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: component-handler/lib/componentLoader.js /** @module component-handler/componentLoader */ 'use strict'; require('string-utils'); const Component = require('component'); const Q = require('q'); const repositoryManager = require('repository-manager'); const componentLoader = exports; /** * Loads a components and initialized with the parameters passed in the function parameters. Furthermore it loads * the recursively all super components in case its defined. * @param {ClientRequest} req * @param {ServerResponse} res * @param {RequestPathInfo} pathInfo * @param {Resource} contentResource * @param {Resource} componentResource * @returns {promise} resolves with the {@link Component} * @alias module:component-handler/componentLoader.load */ componentLoader.load = function(req, res, pathInfo, contentResource, componentResource) { let deferred = Q.defer(); let component = new Component(req, res, pathInfo, contentResource, componentResource); if (componentResource.properties.superComponent != undefined) { repositoryManager.resolve(componentResource.properties.superComponent).then(function(superComponentResource) { return componentLoader.load(req, res, pathInfo, contentResource, superComponentResource); }).then(function(superComponent) { component.superComponent = superComponent; deferred.resolve(component); }).fail(deferred.reject); } else { deferred.resolve(component); } return deferred.promise; }; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"component-handler_lib_dispatcher.js.html":{"id":"component-handler_lib_dispatcher.js.html","title":"Source: component-handler/lib/dispatcher.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: component-handler/lib/dispatcher.js /** @module component-handler/dispatcher */ 'use strict'; const Q = require('q'); const logger = require('dachshund-logger').getLogger(__filename); const repositoryManager = require('repository-manager'); const componentLoader = require(&quot;./componentLoader.js&quot;); const componentHandler = require(&quot;./componentHandler.js&quot;); const resourceTypes = require(&quot;resource-types&quot;); const mime = require(&quot;mime&quot;); const dispatcher = exports; /** * Called when component is processed and the result shall be send within the response * @param {ServerResponse} res - Response to which the data shall be send * @param {RequestPathInfo} pathInfo - To resolve the mime type from the requested file extension * @param {string} data - processed data to be passed back in the HTTP response * @alias module:component-handler/dispatcher.complete */ dispatcher.complete = function(res, pathInfo, data) { let mimetype = mime.lookup(pathInfo.extension); res.writeHead(200, {&quot;Content-Type&quot;: mimetype + &quot;; charset=utf-8&quot;}); res.write(data); res.end(); }; /** * Called when something went wrong while processing the component. It ends the request properly and provides * further information why the request failed * @param {ServerResponse} res - Response to which the data shall be send * @param {string|Error} data - error message which is send back in the HTTP response * @alias module:component-handler/dispatcher.fail */ dispatcher.fail = function(res, data) { let responseMessage = data; let logMessage = data; if (data instanceof Error) { responseMessage = data.message; logMessage = data.message + '\\n' + data.stack; } else if (!(data instanceof String)) { responseMessage = JSON.stringify(data, null, 4); logMessage = responseMessage; } logger.error(logMessage); res.writeHead(500, {&quot;Content-Type&quot;: &quot;text/plain; charset=utf-8&quot;}); res.write(responseMessage); res.end(); }; /** * Dispatched the HTTP request * @param {ClientRequest} req * @param {ServerResponse} res * @param {RequestPathInfo} pathInfo * @param {Resource} contentResource * @alias module:component-handler/dispatcher.dispatchRequest */ dispatcher.dispatchRequest = function(req, res, pathInfo, contentResource) { let deferred = Q.defer(); deferred.promise.then(function(data) { if (data != undefined) { dispatcher.complete(res, pathInfo, data); } }).fail(function(data) { if (data != undefined) { dispatcher.fail(res, data); } }); if (contentResource.properties.componentPath == undefined) { deferred.reject(new Error(&quot;Resource path is not set for resource '&quot; + contentResource.path + &quot;'&quot;)); } let componentResourcePath = contentResource.properties.componentPath; if (contentResource.properties.componentPath == &quot;SELF&quot;) { componentResourcePath = contentResource.path; } repositoryManager.resolve(componentResourcePath).then(function(componentResource) { if(resourceTypes.NOT_FOUND == componentResource.type) { throw new Error('The component resource ['+ componentResourcePath +'] couldn\\'t be found.'); } return componentLoader.load(req, res, pathInfo, contentResource, componentResource); }).then(function(component) { componentHandler.handle(component).then(deferred.resolve).fail(deferred.reject); }).fail(deferred.reject); }; dispatcher.dispatchComponent = function(resourcePath, componentPath, parentComponent, selector) { let deferred = Q.defer(); let contentResource = null; let contentResourceCreated = false; let resourcePropertiesUndefined = false; const resourcePostProcess = function(subComponentResource) { var deferred = Q.defer(); if (contentResourceCreated || resourcePropertiesUndefined) { if (contentResource.properties.timeCreated == undefined) { contentResource.properties.timeCreated = new Date(); } contentResource.properties.componentPath = subComponentResource.path; contentResource.saveProperties().then(deferred.resolve).fail(deferred.reject); } else { deferred.resolve(); } return deferred.promise; }; const loadComponent = function() { if (componentPath == undefined &amp;&amp; contentResource.properties.componentPath != undefined) { componentPath = contentResource.properties.componentPath; repositoryManager.resolve(componentPath).then(function(subComponentResource) { handleComponent(subComponentResource); }).fail(function(err) { logger.error(&quot;Error while resolving resource '&quot; + componentPath + &quot;' because of: &quot; + err.toString()); }); } else if (componentPath != undefined &amp;&amp; componentPath.startsWith(&quot;./&quot;) &amp;&amp; contentResource.properties.componentPath != undefined) { componentPath = contentResource.properties.componentPath + &quot;/&quot; + componentPath.substringAfter(&quot;./&quot;); repositoryManager.resolve(componentPath).then(function(subComponentResource) { handleComponent(subComponentResource); }).fail(function(err) { logger.error(&quot;Error while resolving resource '&quot; + componentPath + &quot;' because of: &quot; + err.toString()); }); } else { repositoryManager.resolve(componentPath).then(function(subComponentResource) { handleComponent(subComponentResource); }).fail(function(err) { logger.error(&quot;Error while resolving resource '&quot; + componentPath + &quot;' because of: &quot; + err.toString()); }); } }; const handleComponent = function(subComponentResource) { resourcePostProcess(subComponentResource).then(function() { if (subComponentResource.type == resourceTypes.NOT_FOUND) { logger.error(&quot;No component resource could be resolved at '&quot; + componentPath + &quot;'&quot;); } let pathInfo = parentComponent.pathInfo; if (selector != undefined) { pathInfo = pathInfo.clone(); pathInfo.selector = selector; } componentLoader.load(parentComponent.req, parentComponent.res, pathInfo, contentResource, subComponentResource).then(function(subComponent) { componentHandler.handle(subComponent).then(deferred.resolve).fail(deferred.reject); }); }).fail(function(err){ logger.error(&quot;Error while executing post process of component because of: &quot; + err.toString()); }); }; if (resourcePath == &quot;&quot; || resourcePath == &quot;.&quot; || resourcePath == &quot;./&quot;) { contentResource = parentComponent.resource; loadComponent(); } else { if (resourcePath.startsWith(&quot;./&quot;)) { resourcePath = parentComponent.resource.path + &quot;/&quot; + resourcePath.substr(2); } else if (!resourcePath.startsWith(&quot;/&quot;) &amp;&amp; !resourcePath.startsWith(&quot;./&quot;)) { resourcePath = parentComponent.resource.path + &quot;/&quot; + resourcePath; } repositoryManager.resolve(resourcePath).then(function(resource) { if (resourceTypes.NOT_FOUND == resource.type) { repositoryManager.createResource(resourcePath, function(resource) { contentResource = resource; contentResourceCreated = true; loadComponent(); }); } else { contentResource = resource; resourcePropertiesUndefined = (contentResource.properties.timeLastChange == undefined); loadComponent(); } }).fail(function(err) { logger.error(&quot;Error while resolving resource '&quot; + resourcePath + &quot;' because of: &quot; + err.toString()); }); } return deferred.promise; }; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"component-handler_lib_prepareScriptHandler.js.html":{"id":"component-handler_lib_prepareScriptHandler.js.html","title":"Source: component-handler/lib/prepareScriptHandler.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: component-handler/lib/prepareScriptHandler.js /** @module component-handler/prepareScriptHandler */ 'use strict'; const Q = require('q'); const logger = require('dachshund-logger').getLogger(__filename); const prepareScriptHandler = exports; /** * @const * @type {number} */ const ELEMENT_NOT_FOUND = -1; /** * A component resource may have a file called 'prepare.js'. This file is executed prior to the component script which * is lookup up based on the {@link RequestPathInfo}. The prepare script is able to enhance the component and enclosed * resource with further information which processed during runtime. * @param component - component as base to lookup the prepare script of this and all super components * @returns {promise} resolves when no prepare could be found or all found prepare scripts are executed succesful * @alias module:component-handler/prepareScriptHandler.resolveAndHandle */ prepareScriptHandler.resolveAndHandle = function(component) { let deferred = Q.defer(); // Step 1: Lookup the prepare script of the component and all super components // This promise fails when no prepare script could be found prepareScriptHandler.resolvePrepareScripts(component).then(function(prepareScriptList) { let prepareScriptPromises = []; //Step 2: Execute them and collect the promises prepareScriptList.forEach(function(prepareScript) { prepareScriptPromises.push(component.executeScript(prepareScript)); }); logger.trace(prepareScriptList.length + &quot; prepare script for component [&quot; + component.componentResource.path + &quot;] processed&quot;); //Step 3: Wait until all prepare scripts are executed or one failed Q.all(prepareScriptPromises).then(deferred.resolve).fail(function(error){ logger.error(&quot;Error while executing prepare script [&quot;+ error.toString() +&quot;]&quot;); deferred.reject(); }); }).fail(function() { logger.trace(&quot;No prepare script for component [&quot; + component.componentResource.path + &quot;]&quot;); deferred.resolve(); }); return deferred.promise; }; /** * * @param {Component} component * @param {string[]} prepareScripts * @returns {promise} resolved with */ prepareScriptHandler.resolvePrepareScripts = function(component, prepareScripts) { let deferred = Q.defer(); let self = this; if (prepareScripts == undefined) { prepareScripts = []; } component.resolveScript(&quot;prepare&quot;, true, &quot;js&quot;).then(function(prepareScript) { if (prepareScript != null &amp;&amp; prepareScripts.indexOf(prepareScript) == ELEMENT_NOT_FOUND) { prepareScripts.push(prepareScript); } if (component.superComponent != null) { self.resolvePrepareScripts(component.superComponent, prepareScripts).then(deferred.resolve); } else { deferred.resolve(prepareScripts); } }).fail(function() { if (prepareScripts.length == 0) //The component has no prepare scripts, reject the further processing { deferred.reject(); } else //The component has no further prepare script then the ones which are already found { deferred.resolve(prepareScripts); } }); return deferred.promise; }; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"component-script-handler_lib_componentScriptHandler_jazzHandler.js.html":{"id":"component-script-handler_lib_componentScriptHandler_jazzHandler.js.html","title":"Source: component-script-handler/lib/componentScriptHandler/jazzHandler.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: component-script-handler/lib/componentScriptHandler/jazzHandler.js /** * The Jazz handler handles all HTML templates with the file extension *.jazz. The source and documentation of the templating engine can be found here {@link https://github.com/shinetech/jazz}. The templating engine makes it possible to write html code and to enhance it with place holder, conditions, loops and further predefined javascript methods. Since this handle is executed in a context of a component, it provides access to resource its properties but also to include further scripts from component resource or to include other resources. In addition to the standard functions defined in the jazz documentation the following additional functioanlity is provided: * * ### Access Content Resource Property * ```html * Hello {properties.yourFirstName} you age is {properties.age} * * &lt;!-- Access a property from the resource of the component trough a method --&gt; * &lt;!-- define a default value, which is uses in case the property doesn't exists --&gt; * Hello {getProperty('yourName', 'John Doe')} you age is {getProperty('age', 42)} * ``` * * ### Conditional Statements * ``` * {if properties.yourFirstName} * Hello, {properties.yourFirstName} * {end} * * &lt;!-- with else clause --&gt; * {if properties.yourFirstName} * Hello, {properties.yourFirstName} * {else} * Hello Anonymous * {end} * * &lt;!-- or with else if --&gt; * {if properties.yourFirstName} * Hello, {properties.yourFirstName} * {elif properties.yourLastName} * Hello, Mr. {properties.yourLastName} * {else} * Hello Anonymous * {end} * * &lt;!-- with logical expressions --&gt; * {if properties.yourFirstName and properties.yourLastName} * Hello {properties.yourFirstName} {properties.yourLastName} * {end} * * {if properties.usesATablet or properties.usesASmartphone} * You access the site with a mobile device. * {end} * * {if not properties.driversLicence} * You are not allowed to drive a car. * {end} * * &lt;!-- comparing two values with eq (equals) or neq (not equals) --&gt; * {if properties.gender eq 'male'} * Hello, Mr. {properties.yourLastName} * {end} * * {if properties.status neq 'offline'} * You're online! * {end} * ``` * * ### Looping Over an Object * ``` * {foreach childPage in properties.chilePages} * &lt;p&gt;&lt;a href='{childPage.path}.html'&gt;{childPage.name}&lt;/a&gt;&lt;/p&gt; * {end} * * &lt;!-- using counters / index --&gt; * {foreach childPage in properties.chilePages} * &lt;p&gt;&lt;a href='{childPage.path}.html'&gt;{childPage.name}&lt;/a&gt;&lt;/p&gt; * &lt;p&gt;Loop number (1 based): {__count}&lt;/p&gt; * &lt;p&gt;Index (0 based): {__index}&lt;/p&gt; * {end} * ``` * * ### Include Script from Component Resource * The result will be added into the calling jazz file. The execution takes place in the same context. * ``` * {includeScript('nameOfTheOtherScriptInComponentResource.jazz')} * ``` * * ### Include Components &lt;a name=&quot;includeComponent&quot;&gt;&lt;/a&gt; * ``` * &lt;!-- The path can be relative or absolute. --&gt; * {includeComponent('footer')} * {includeComponent('./footer')} * {includeComponent('../parentPath')} * {includeComponent('/complete/path/to/other/contentResource')} * * &lt;!-- It is also possible to define the component resource which shall be taken. In this case the defined --&gt; * &lt;!-- 'resourcePath' property on the content resource will be ignored --&gt; * {includeComponent('footer', '/apps/myApp/footer')} * * &lt;!-- When the component provides different renditions depending on the selector, the selector can be passed on --&gt; * &lt;!-- as well, to provide for example overview, detail or edit view with one component --&gt; * {includeComponent('footer', '/apps/myApp/footer', 'compact')}` * ``` * * ### Further Utility Functions * ``` * &lt;!-- Furthermore some methods are provided to utilize the templating process --&gt; * * &lt;!-- Use translation with nodejs module i18n --&gt; * {i18n(variableOrStringToBeTranslated)} * * &lt;!-- Check if in an element from an array is the last one, returns true if this is the case --&gt; * {isLastElement(arrayToBeChecked, elementFromArray)} * * &lt;!-- Negates an boolean value --&gt; * {isNot(booleanVariable)} * * &lt;!-- Checks if a variable is undefined and return true if this th case --&gt; * {isUndefined(variableToBeChecked)} * * &lt;!-- Checks if a variable is defined returns true if this is the case --&gt; * {isDefined(variableToBeChecked)} * * &lt;!-- Escapes special charactors in a string --&gt; * {escape(stringToBeEscaped)}` * ``` * * @module component-script-handler/jazzHandler */ 'use strict'; require('string-utils'); const Q = require('q'); const fs = require('graceful-fs'); const jazz = require(&quot;jazz&quot;); const dispatcher = require('component-handler'); const escape = require(&quot;html-escape&quot;); const logger = require('dachshund-logger').getLogger(__filename); const jazzHandler = exports; jazzHandler.extension = &quot;jazz&quot;; jazzHandler.handle = function(component, scriptPath, parameter) { let deferred = Q.defer(); Q.nfapply(fs.readFile, [process.cwd() + scriptPath, {encoding: 'utf8'}]).then(function(jazzTemplate) { logger.trace(&quot;Handling jazz file [&quot; + scriptPath + &quot;]&quot;); return jazzHandler.handleJazzTemplate(component, jazzTemplate, parameter); }).then(deferred.resolve).fail(deferred.reject); return deferred.promise; }; jazzHandler.handleJazzTemplate = function(component, jazzTemplate, parameter) { let deferred = Q.defer(); let templateParameters = { &quot;i18n&quot;: component.res.__, &quot;includeComponent&quot;: function(path, componentPath, selector, cb) { if (cb != undefined &amp;&amp; selector != undefined) { jazzHandler.includeComponent(path, componentPath, cb, component, selector); } else if (cb == undefined &amp;&amp; selector != undefined) { cb = selector; jazzHandler.includeComponent(path, componentPath, cb, component); } else { cb = componentPath; componentPath = undefined; jazzHandler.includeComponent(path, componentPath, cb, component, selector); } }, &quot;getProperty&quot;: function(propertyName, defaultValue, cb) { if (cb == undefined) { cb = defaultValue; defaultValue = &quot;&quot;; } cb(component.resource.properties[propertyName] == undefined ? defaultValue : component.resource.properties[propertyName]); }, &quot;isAuthorized&quot;: function(type, path, cb) { let isAuthorized = false; let resource = component.resource; if (cb == undefined) { cb = path; path = component.resource.path; } let evaluateResourceIsAuthorized = function(resource) { cb(resource.isAuthorized(type)); }; if (path != component.resource.path) { component.req.session.resolve(path).then(evaluateResourceIsAuthorized).fail(function(err){ logger.error(&quot;Error while resolving resource '&quot;+ path +&quot;' because of: &quot; + err.toString()); cb(false); }); } else { evaluateResourceIsAuthorized(component.resource); } }, &quot;isLastElement&quot;: function(array, element) { if (array instanceof Array) { let lastElementMatches = array[array.length - 1] == element; return lastElementMatches; } return false; }, &quot;isNot&quot;: function(boolean) { return boolean != undefined &amp;&amp; !boolean; }, &quot;isDefined&quot;: function(element) { return element != undefined; }, &quot;isUndefined&quot;: function(element) { return element == undefined; }, &quot;toJson&quot;: function(object, cb) { if (cb == undefined) { return JSON.stringify(object); } else { cb(JSON.stringify(object)); } }, &quot;escape&quot;: function(value, cb) { if (cb == undefined) { return escape(value); } else { cb(escape(value)); } }, &quot;includeScript&quot;: function(scriptFilenamename, parameter, cb) { if (cb == undefined) { cb = parameter; } jazzHandler.includeScript(scriptFilenamename, cb, component, parameter); }, &quot;nullReference&quot;: function() { return null; }, &quot;properties&quot;: component.resource.properties, &quot;component&quot;: component, &quot;resource&quot;: component.resource, &quot;pathInfo&quot;: component.pathInfo, &quot;parameter&quot;: parameter }; try { let template = jazz.compile(jazzTemplate); template.eval(templateParameters, function(data) { deferred.resolve(data); }); } catch (err) { deferred.reject(err); } return deferred.promise }; jazzHandler.includeComponent = function(resourcePath, componentPath, cb, component, selector) { if (resourcePath != null &amp;&amp; resourcePath.path != undefined) { resourcePath = resourcePath.path; } dispatcher.dispatchComponent(resourcePath, componentPath, component, selector).then(cb).fail(function(err) { let errorMessage = &quot;Error while including component '&quot; + componentPath + &quot;' with resource path '&quot; + resourcePath + &quot;' &gt;&gt; &quot; + err; logger.error(errorMessage); cb(errorMessage); }); }; jazzHandler.includeScript = function(scriptFilename, cb, component, parameter) { let scriptName = scriptFilename.lastSubstringBefore(&quot;.&quot;); let scriptExtension = scriptFilename.lastSubstringAfter(&quot;.&quot;); component.executeScript(scriptName, scriptExtension, parameter).then(cb).fail(function(err) { let errorMessage = &quot;Error while including script '&quot; + scriptFilename + &quot;' within component '&quot; + component.componentResource.path + &quot;' &gt;&gt; &quot; + err; logger.error(errorMessage); cb(errorMessage); }); }; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"component-script-handler_lib_componentScriptHandler.js.html":{"id":"component-script-handler_lib_componentScriptHandler.js.html","title":"Source: component-script-handler/lib/componentScriptHandler.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: component-script-handler/lib/componentScriptHandler.js /** * The component script handler contains all methods to handle files defined in the component resource. The script * handler are held in the folder './componentScriptHandler' and are responsible to manage files with different * file extensions. Currently the following script handler are defined: * - __Javascript Handler__ Handles all script files with the file extension _*.js_ * - __Jazz Handler__ Handles all jazz template files with the file extension _*.jazz_ * - __LessCSS Handler__ Handles all less css files with the file extension _*.less_ * - __Static Handler__ Handles all files with the file extension _*.static_ * * @module componentScriptHandler */ 'use strict'; const fs = require(&quot;fs&quot;); const logger = require('dachshund-logger').getLogger(__filename); let _scriptHandler = undefined; exports.getScriptHandler = function(extension) { if (_scriptHandler == undefined) { loadScriptHandler(); } return _scriptHandler[extension]; }; const loadScriptHandler = function() { _scriptHandler = {}; fs.readdirSync(__dirname + &quot;/componentScriptHandler&quot;).forEach(function(file) { try { let scriptHandler = require(&quot;./componentScriptHandler/&quot; + file); _scriptHandler[scriptHandler.extension] = scriptHandler; } catch (err) { logger.error(&quot;Error while loading component script handler '&quot;+ file +&quot;' because of: &quot; + err) } }); }; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"dachshund-logger_lib_DachshundLogger.js.html":{"id":"dachshund-logger_lib_DachshundLogger.js.html","title":"Source: dachshund-logger/lib/DachshundLogger.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: dachshund-logger/lib/DachshundLogger.js /** @module dachshund-logger */ 'use strict'; const log4js = require('log4js'); const stringUtils = require('string-utils'); const assert = require('assert'); /** * Creates a logger which wraps the log4js logger {@link https://www.npmjs.com/package/log4js} * @param filename Filename as it is given by the __filename environment variable * * @example * //Include logger in node.js module * const logger = require('dachshund-logger').getLogger(__filename); * * //Use logge in node.js module * logger.trace('Trace message'); * logger.debug('Debug message'); * logger.info('Info message'); * logger.warn('Warn message'); * logger.error('Error message'); * logger.fatal('Fatal message'); */ exports.getLogger = function(filename) { assert(stringUtils.isNotEmpty(filename), 'Filename is not given'); let logger = {}; logger.loggingPath = filename.substring(process.cwd().length); logger.logger = log4js.getLogger(logger.loggingPath); for (let loggerAttribute in logger.logger) { logger[loggerAttribute] = logger.logger[loggerAttribute]; } return logger; }; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"file-script-handler_lib_fileScriptHandler_imageDimensionsHandler.js.html":{"id":"file-script-handler_lib_fileScriptHandler_imageDimensionsHandler.js.html","title":"Source: file-script-handler/lib/fileScriptHandler/imageDimensionsHandler.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: file-script-handler/lib/fileScriptHandler/imageDimensionsHandler.js /** @module file-script-handler/imageDimensionsHandler */ 'use strict'; const im = require('imagemagick'); const imageDimensionsHandler = exports; const logger = require('dachshund-logger').getLogger(__filename); const repositoryManager = require('repository-manager'); const Q = require('q'); const extractMetadata = function(metadata) { let metadataObject = { type: &quot;&quot;, dimensions: &quot;&quot;, width: 0, height: 0, sizeInBytes: 0 }; let metadataParts = metadata.split(&quot; &quot;); try { metadataObject.sizeInBytes = parseInt(metadataParts[0].substring(0,metadataParts[0].length - 1)); metadataObject.type = metadataParts[1]; metadataObject.width = parseInt(metadataParts[2]); metadataObject.height = parseInt(metadataParts[3]); metadataObject.dimensions = metadataObject.width + &quot;x&quot; + metadataObject.height; }catch(ex){ logger.error(&quot;Error while transforming image metadata: &quot; + ex); } return metadataObject; }; imageDimensionsHandler.test = function(pathInfo) { let extension = pathInfo.extension.toLowerCase(); if(pathInfo.selector == null) { return false; } let selectorParts = pathInfo.selector.split(&quot;.&quot;); if(selectorParts.length &lt; 2) { return false; } let secondLastSelector = selectorParts[selectorParts.length - 2].toLowerCase(); let lastSelector = selectorParts[selectorParts.length - 1].toLowerCase(); return lastSelector == &quot;dimensions&quot; &amp;&amp; (secondLastSelector == &quot;png&quot; || secondLastSelector == &quot;gif&quot; || secondLastSelector == &quot;jpg&quot; || secondLastSelector == &quot;jpeg&quot;) &amp;&amp; extension == &quot;json&quot;; }; imageDimensionsHandler.handle = function(req, resp, pathInfo, resource) { let selectorParts = pathInfo.selector.split(&quot;.&quot;); //Remove the &quot;dimensions&quot; from the selector list selectorParts.splice(selectorParts.length - 1, 1); if(selectorParts.length &gt; 2 &amp;&amp; selectorParts[selectorParts.length - 3] == &quot;min&quot; || selectorParts[selectorParts.length - 3] == &quot;max&quot;) { selectorParts.splice(selectorParts.length - 3, 1); } if(selectorParts.length &gt; 1 &amp;&amp; selectorParts[selectorParts.length - 2].contains(&quot;x&quot;)) { selectorParts.splice(selectorParts.length - 2, 1); } let selector = selectorParts.join(&quot;.&quot;); let naturalImagePath = pathInfo.componentPath + &quot;.&quot; + selector; repositoryManager.resolve(naturalImagePath).then(function(resource){ let imagePath = naturalImagePath; if(resource.source != undefined) { imagePath = resource.source; } return Q.nfcall(im.identify, [&quot;-format&quot;, &quot;%b %m %w %h&quot;, process.cwd() + imagePath]); }).then(function(metadata){ let metadataObject = extractMetadata(metadata); metadataObject.imagePath = naturalImagePath; resp.writeHead(200, {&quot;Content-Type&quot; : &quot;application/json; charset=utf-8&quot;}); resp.write(JSON.stringify(metadataObject)); resp.end(); }).fail(function(err){ resp.writeHead(500, {&quot;Content-Type&quot; : &quot;text/plain; charset=utf-8&quot;}); resp.write(&quot;Error while reading image dimensions &quot; + err); resp.end(); }); }; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"file-script-handler_lib_fileScriptHandler_imageExifHandler.js.html":{"id":"file-script-handler_lib_fileScriptHandler_imageExifHandler.js.html","title":"Source: file-script-handler/lib/fileScriptHandler/imageExifHandler.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: file-script-handler/lib/fileScriptHandler/imageExifHandler.js /** @module file-script-handler/imageExifHandler */ 'use strict'; require('string-utils'); const fs = require('fs'); const im = require('imagemagick'); const path = require(&quot;path&quot;); const nodeStatic = require('node-static'); const qs = require('querystring'); const childProcess = require('child_process'); const logger = require('dachshund-logger').getLogger(__filename); const DachshundError = require('dachshund-error'); const geocoder = require('geocoder'); const resourceTypes = require('resource-types'); const imageExifHandler = exports; const repositoryManager = require('repository-manager'); const Q = require('q'); const sha256 = require('sha256'); const temp = require(&quot;temp&quot;).track(); fileServer = new nodeStatic.Server({ cache: false }); let pathToExifTool = null; if (fs.existsSync(&quot;/usr/bin/exiftool&quot;)) { pathToExifTool = &quot;/usr/bin/exiftool&quot;; } else if (fs.existsSync(&quot;/usr/local/bin/exiftool&quot;)) { pathToExifTool = &quot;/usr/local/bin/exiftool&quot;; } else { logger.error(&quot;Path to command line tool [exiftool] could not be found.&quot;); } imageExifHandler.test = function(pathInfo) { let extension = pathInfo.extension.toLowerCase(); if (pathInfo.selector == null) { return false; } let selectorParts = pathInfo.selector.split(&quot;.&quot;); let greatestSelectorPart = selectorParts[selectorParts.length - 1].toLowerCase(); return (greatestSelectorPart == &quot;jpg&quot; || greatestSelectorPart == &quot;jpeg&quot;) &amp;&amp; extension == &quot;json&quot;; }; imageExifHandler.handle = function(req, resp, pathInfo) { let selectorParts = pathInfo.selector.split(&quot;.&quot;); if (selectorParts.length &gt; 2 &amp;&amp; selectorParts[selectorParts.length - 3] == &quot;min&quot; || selectorParts[selectorParts.length - 3] == &quot;max&quot;) { selectorParts.splice(selectorParts.length - 3, 1); } if (selectorParts.length &gt; 1 &amp;&amp; selectorParts[selectorParts.length - 2].contains(&quot;x&quot;)) { selectorParts.splice(selectorParts.length - 2, 1); } let selector = selectorParts.join(&quot;.&quot;); let imagePath = pathInfo.componentPath + &quot;.&quot; + selector; req.session.resolve(imagePath).then(function(imageResource) { let deferred = Q.defer(); if (resourceTypes.isFile(imageResource)) { let imageSourcePath = imagePath; if (imageResource.source != undefined) { imageSourcePath = imageResource.source; } if (pathInfo.method == &quot;GET&quot;) { processRequestReadExifData(req, resp, pathInfo, imagePath, imageSourcePath).fail(deferred.reject); } else if (pathInfo.method == &quot;POST&quot;) { processRequestModifyExifData(req, resp, pathInfo, imagePath, imageSourcePath).fail(deferred.reject); } else { deferred.reject(new DachshundError(&quot;The selected method cannot be handled&quot;, 500)); } } else { deferred.reject(new DachshundError(&quot;The selected source file does not exist&quot;, 404)); } return deferred.promise; }).fail(function(err) { resp.writeHead(err.id || 500, {&quot;Content-Type&quot;: &quot;text/plain; charset=utf-8&quot;}); resp.write(err.toString()); resp.end(); }); }; const processRequestModifyExifData = function(req, resp, pathInfo, imagePath, imageSourcePath) { let deferred = Q.defer(); let imageFolder = imagePath.lastSubstringBefore(&quot;/&quot;); let imageName = imagePath.lastSubstringAfter(&quot;/&quot;); let imageMetaName = &quot;.&quot; + imageName + &quot;.exif.json&quot;; req.session.resolve(imageFolder, function(imageFolderResource) { if (!imageFolderResource.isAuthorized(&quot;modify&quot;)) { deferred.reject(new DachshundError(&quot;You're not authorized to modify image exif data.&quot;, 401)); } else { let body = ''; req.on('data', function(data) { body = body + data; }); req.on('end', function() { let postParameters = qs.parse(body); let imageDescription = postParameters.imageDescription; if (imageDescription == undefined) { deferred.reject(new DachshundError(&quot;The parameter 'imageDescription' is undefined in the post request.&quot;, 500)); } else { processImageDescription(imageSourcePath, imageDescription).then(function() { return repositoryManager.resolve(imageFolder); }).then(function(imageFolderResource) { let deferred = Q.defer(); let imageReadStream = fs.createReadStream(&quot;.&quot; + imageSourcePath); imageFolderResource.addFile(imageReadStream, imageName).then(function() { deferred.resolve(imageFolderResource); }).fail(deferred.reject); return deferred.promise; }).then(function(imageFolderResource) { let deferred = Q.defer(); imageFolderResource.fileExists(imageMetaName).then(function(fileExists) { if (fileExists) { imageFolderResource.deleteFile(imageMetaName).then(deferred.resolve).fail(deferred.reject); } else { deferred.resolve(undefined); } }); return deferred.promise; }).then(function() { processRequestReadExifData(req, resp, pathInfo, imagePath, imageSourcePath); }).fail(deferred.reject); } }); } }); return deferred.promise; }; const processRequestReadExifData = function(req, resp, pathInfo, imagePath, imageSourcePath) { let deferred = Q.defer(); let imageFolder = imagePath.lastSubstringBefore(&quot;/&quot;); let imageName = imagePath.lastSubstringAfter(&quot;/&quot;); let imageMetaName = &quot;.&quot; + imageName + &quot;.exif.json&quot;; let imageMetaPath = imageFolder + &quot;/&quot; + imageMetaName; repositoryManager.resolve(imageMetaPath).then(function(imageMetaResource) { let deferred = Q.defer(); if (resourceTypes.isFile(imageMetaResource)) { let imageExifFilePath = &quot;.&quot; + imageMetaResource.source || imageMetaPath; fileServer.serveFile(imageExifFilePath, 200, {&quot;content-type&quot;: &quot;application/json; charset=utf-8&quot;}, req, resp); } else { Q.nfcall(im.readMetadata, process.cwd() + imageSourcePath).then(function(metadata) { if (metadata.exif != undefined) { metadata = metadata.exif; //Reset senseless and cluttered exif properties delete metadata.makerNote; delete metadata.userComment; processImageDescription(imageSourcePath).then(function(imageDescription) { metadata.imageDescription = imageDescription; return processGpsData(metadata); }).then(function(gpsPosition) { metadata.gpsPosition = gpsPosition; return Q.nfcall(temp.open, sha256(imageMetaPath)); }).then(function(tempInfo) { let deferred = Q.defer(); let exifDataString = JSON.stringify(metadata); fs.writeFile(tempInfo.path, exifDataString, function() { deferred.resolve(tempInfo); }); return deferred.promise; }).then(function(tempInfo) { let deferred = Q.defer(); let exifTempFile = fs.createReadStream(tempInfo.path); repositoryManager.resolve(imageFolder).then(function(imageFolderResource) { return imageFolderResource.addFile(exifTempFile, imageMetaName); }).then(deferred.resolve).fail(deferred.reject); return deferred.promise; }).then(function() { processRequestReadExifData(req, resp, pathInfo, imagePath); }).fail(deferred.reject); } else { let metadata = { imageDescription: &quot;&quot; }; Q.nfcall(temp.open, sha256(imageMetaPath)).then(function(tempInfo) { let deferred = Q.defer(); let exifDataString = JSON.stringify(metadata); fs.writeFile(tempInfo.path, exifDataString, function() { deferred.resolve(tempInfo); }); return deferred.promise; }).then(function(tempInfo) { let exifTempFile = fs.createReadStream(tempInfo.path); return imageMetaResource.addFile(exifTempFile, imageMetaName); }).then(function() { processRequestReadExifData(req, resp, pathInfo, imagePath); }).fail(deferred.reject); } }).fail(deferred.reject); } return deferred.promise; }); return deferred.promise; }; const processImageDescription = function(imagePath, description) { let deferred = Q.defer(); let writeDescription = (description != undefined &amp;&amp; description != null); let spawn = childProcess.spawn; let processArguments = [&quot;-T&quot;, &quot;-ImageDescription&quot;, process.cwd() + imagePath]; if (writeDescription) { processArguments = [&quot;-codedcharacterset=UTF8&quot;, &quot;-overwrite_original&quot;, &quot;-Exif:ImageDescription=&quot; + description, process.cwd() + imagePath] } let child = spawn(pathToExifTool, processArguments); let stdout = ''; let stderr = ''; child.stdout.setEncoding('utf8'); child.stdout.on('data', function(buf) { stdout += buf.toString(); }); child.stderr.on('data', function(buf) { stderr += buf.toString(); }); child.on('close', function(code) { if (code != 0) { logger.error(&quot;Error while executing exiftool. Exit code '&quot; + code + &quot;' with error message: &quot; + stderr); deferred.resolve(undefined); } else { stdout = stdout.replaceAll(&quot;\\n&quot;, &quot;&quot;); if (writeDescription) { stdout = description; } else if (stdout == &quot;-&quot;) { stdout = &quot;&quot;; } deferred.resolve(stdout); } }); return deferred.promise; }; const processGpsData = function(exifData, cb) { let deferred = Q.defer(); if (exifData.gpsLatitude == undefined || exifData.gpsLatitudeRef == undefined || exifData.gpsLongitude == undefined || exifData.gpsLongitudeRef == undefined) { deferred.resolve(undefined); } else { let altitude = 0.0; if (exifData.gpsAltitude != undefined) { let stringAltitude = exifData.gpsAltitude.split(&quot;/&quot;); altitude = parseFloat(stringAltitude[0]) / parseFloat(stringAltitude[1]); } let latitude = convertToDegree(exifData.gpsLatitude); if (exifData.gpsLatitudeRef != &quot;N&quot;) { latitude = 0 - latitude; } let longitude = convertToDegree(exifData.gpsLongitude); if (exifData.gpsLongitudeRef != &quot;E&quot;) { longitude = 0 - convertToDegree(exifData.gpsLongitude); } //Check the plausibility of the calculated data. //If all values are zero it can't be an official position. if (latitude == 0 &amp;&amp; longitude == 0 &amp;&amp; altitude == 0) { logger.warn(&quot;The gps position isn't plausable and won't be persisted.&quot;); deferred.resolve(undefined); } else { let location = { &quot;latitude&quot;: latitude, &quot;longitude&quot;: longitude, &quot;altitude&quot;: altitude }; resolveGeoLocation(location).then(function(geolocation) { location.geolocation = geolocation; deferred.resolve(location); }); } } return deferred.promise; }; const resolveGeoLocation = function(location) { let deferred = Q.defer(); if (location != undefined) { Q.nfcall(geocoder.reverseGeocode, location.latitude, location.longitude, { language: 'de' }).then(function(data) { deferred.resolve(data.results[0].formatted_address); }).fail(function(err) { logger.warn(&quot;The gps position isn't plausible and won't be persisted.&quot;); deferred.resolve(&quot;&quot;); }); } else { deferred.resolve(&quot;&quot;); } return deferred.promise; }; const convertToDegree = function(stringDMS) { let result = 0; let DMS = stringDMS.split(&quot;,&quot;); let stringDegree = DMS[0].split(&quot;/&quot;); let floatDegree = parseFloat(stringDegree[0]) / parseFloat(stringDegree[1]); let stringMinutes = DMS[1].split(&quot;/&quot;); let floatMinutes = parseFloat(stringMinutes[0]) / parseFloat(stringMinutes[1]); let stringSeconds = DMS[2].split(&quot;/&quot;); let floatSeconds = parseFloat(stringSeconds[0]) / parseFloat(stringSeconds[1]); return floatDegree + (floatMinutes / 60) + (floatSeconds / 3600); }; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"file-script-handler_lib_fileScriptHandler_imageSizeHandler.js.html":{"id":"file-script-handler_lib_fileScriptHandler_imageSizeHandler.js.html","title":"Source: file-script-handler/lib/fileScriptHandler/imageSizeHandler.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: file-script-handler/lib/fileScriptHandler/imageSizeHandler.js /** @module file-script-handler/imageSizeHandler */ 'use strict'; const fs = require('fs'); const path = require(&quot;path&quot;); const im = require('imagemagick'); const Q = require('q'); const DachshundError = require('dachshund-error'); const resourceTypes = require('resource-types'); const mime = require('mime'); const temp = require('temp').track(); const sha256 = require('sha256'); const repositoryManager = require('repository-manager'); const stringUtils = require('string-utils'); const imageSizeHandler = exports; const nodeStatic = require('node-static'); const fileServer = new nodeStatic.Server({ cache: false }); const assert = require('assert'); imageSizeHandler.test = function(pathInfo) { let extension = pathInfo.extension.toLowerCase(); let correctExtension = extension == &quot;jpg&quot; || extension == &quot;jpeg&quot; || extension == &quot;png&quot; || extension == &quot;gif&quot;; let selectorIsDefined = stringUtils.isNotEmpty(pathInfo.selector); return selectorIsDefined &amp;&amp; correctExtension; }; /** * Resolves the image thumbnail or creates it, for the case that it doesn't exist * @param req * @param resp * @param pathInfo */ imageSizeHandler.handle = function(req, resp, pathInfo) { try { let thumbProperties = new ImageProperties(pathInfo); } catch (err) { resp.writeHead(500, {&quot;content-type&quot;: &quot;text/plain; charset=utf-8&quot;}); resp.write(err.toString()); resp.end(); return; } req.session.resolve(thumbProperties.sourceFilePath).then(function(imageParentResource) { let deferred = Q.defer(); //Step 1: Check if the resource exists and access is allowed if (!resourceTypes.isResource(imageParentResource)) { deferred.reject(new DachshundError(&quot;404 Resource not found&quot;, 404)); } else { //Step 2: Check if source image exists imageParentResource.fileExists(thumbProperties.sourceFileName).then(function(sourceFileExists) { if (!sourceFileExists) { deferred.reject(new DachshundError(&quot;404 Resource not found&quot;, 404)); } else { deferred.resolve(imageParentResource); } }); } return deferred.promise; }).then(function(imageParentResource) { let deferred = Q.defer(); //Step 3: Check if the thumb image is already created imageParentResource.fileExists(thumbProperties.thumbFileName).then(function(thumbFileExists) { if (thumbFileExists) { //Step 4a: Serve the image when it exists deferred.resolve(thumbProperties); } else { //Step 4b: Create the thumbnail and serve it when it's created createThumbnail(thumbProperties).then(function() { deferred.resolve(thumbProperties); }).fail(deferred.reject); } }); return deferred.promise; }).then(function(thumbProperties) { let thumbImagePath = thumbProperties.sourceFilePath + &quot;/&quot; + thumbProperties.thumbFileName; req.session.resolve(thumbImagePath).then(function(thumbFileResource) { let thumbImageFilePath = &quot;.&quot; + (thumbFileResource.source || thumbImagePath); let mimetype = mime.lookup(pathInfo.extension); fileServer.serveFile(thumbImageFilePath, 200, {&quot;content-type&quot;: mimetype}, req, resp); }); }).fail(function(err) { resp.writeHead(err.id || 500, {&quot;Content-Type&quot;: &quot;text/plain; charset=utf-8&quot;}); resp.write(err.toString()); resp.end(); }); }; /** * Creates the thumbnail and stores it at the parent resource where the original image belongs to * @param {ImageProperties} thumbProperties Information about the thumbnail process * @returns {*} */ const createThumbnail = function(thumbProperties) { let deferred = Q.defer(); let completeSourcePath = thumbProperties.sourceFilePath + &quot;/&quot; + thumbProperties.sourceFileName; let sourceFilePath = &quot;&quot;; //Step 1: Access the source image repositoryManager.resolve(completeSourcePath).then(function(sourceImageResource) { sourceFilePath = sourceImageResource.source || completeSourcePath; //Step 2: Read the the image exif information return Q.nfcall(im.readMetadata, process.cwd() + sourceFilePath); }).then(function(metadata) { let deferred = Q.defer(); //Step 3a: Set the size depending on the orientation of the image let size = thumbProperties.getSizeVertical(); if (metadata.exif != undefined &amp;&amp; metadata.exif.orientation != undefined) { // All orientations great as 4 are a pictures is // horizontal instead of vertical // Details are here documented: // http://sylvana.net/jpegcrop/exif_orientation.html if (metadata.exif.orientation &gt; 4) { size = thumbProperties.getSizeHorizontal(); } } //Step 3b: If the minimum size instead of the maximum is requested, the requested size has to be prefixed for image magic if (thumbProperties.type == &quot;min&quot;) { size += &quot;^&quot;; } //Step 4: Create a temporary file where the image is written to, until it will be added to the resource Q.nfcall(temp.open, sha256(completeSourcePath)).then(function(tempInfo) { //Step 5: Create the image thumbnail and write it into the temporary file Q.nfcall(im.convert, [ process.cwd() + sourceFilePath, '-resize', size, tempInfo.path]).then(function() { deferred.resolve(tempInfo.path); }).fail(deferred.reject); }).fail(deferred.reject); return deferred.promise; }).then(function(thumbnailPath) { let deferred = Q.defer(); //Step 6: Switch the orientation of the image, if it was taken vertical Q.nfcall(im.convert, [ '-auto-orient', thumbnailPath, thumbnailPath]).then(function() { deferred.resolve(thumbnailPath); }).fail(deferred.reject); return deferred.promise; }).then(function(thumbnailPath) { let deferred = Q.defer(); //Step 7: Resolve the resource where the image will be attched to repositoryManager.resolve(thumbProperties.sourceFilePath).then(function(imageParentResource) { //Step 8: Attach thumbnail to the parent resource of the source image let thumbnailReadStream = fs.createReadStream(thumbnailPath); imageParentResource.addFile(thumbnailReadStream, thumbProperties.thumbFileName).then(deferred.resolve).fail(deferred.reject); }).fail(deferred.reject); return deferred.promise; }).then(deferred.resolve).fail(deferred.reject); return deferred.promise; }; /** * Resolves the necessary parameters to create the image thumbnail * * @param pathInfo RequestPathInfo object resolved from the http request */ const ImageProperties = function(pathInfo) { assert(stringUtils.isNotEmpty(pathInfo.selector), &quot;Selector isn't defined&quot;); let selectorParts = pathInfo.selector.split(&quot;.&quot;); if (selectorParts.length &gt;= 2) { if (selectorParts[selectorParts.length - 2] == &quot;min&quot; || selectorParts[selectorParts.length - 2] == &quot;max&quot;) { this.type = selectorParts[selectorParts.length - 2]; selectorParts.splice(selectorParts.length - 2, 1); } this.size = selectorParts[selectorParts.length - 1]; selectorParts.splice(selectorParts.length - 1, 1); } else { this.size = selectorParts[0]; selectorParts = []; } assert(stringUtils.isNotEmpty(this.size), &quot;Size isn't defined within request selector.&quot;); let sizeParts = this.size.split(&quot;x&quot;); assert.equal(sizeParts.length, 2, &quot;Size selector is malformed.&quot;); this.width = parseInt(sizeParts[0]); assert(!isNaN(this.width), &quot;Defined width isn't a number&quot;); this.height = parseInt(sizeParts[1]); assert(!isNaN(this.height), &quot;Defined height isn't a number&quot;); let completeSourcePath = pathInfo.componentPath + &quot;.&quot; + pathInfo.extension; if (selectorParts.length &gt; 0) { completeSourcePath = pathInfo.componentPath + &quot;.&quot; + selectorParts.join(&quot;.&quot;) + &quot;.&quot; + pathInfo.extension; } this.sourceFilePath = completeSourcePath.lastSubstringBefore(&quot;/&quot;); this.sourceFileName = completeSourcePath.lastSubstringAfter(&quot;/&quot;); this.thumbFileName = &quot;.&quot; + this.sourceFileName.lastSubstringBefore(&quot;.&quot;) + &quot;.&quot; + this.type + &quot;.&quot; + this.size + &quot;.&quot; + pathInfo.extension }; ImageProperties.prototype.type = &quot;max&quot;; ImageProperties.prototype.size = &quot;&quot;; ImageProperties.prototype.height = 0; ImageProperties.prototype.width = 0; ImageProperties.prototype.sourceFilePath = &quot;&quot;; ImageProperties.prototype.sourceFileName = &quot;&quot;; ImageProperties.prototype.thumbFileName = &quot;&quot;; ImageProperties.prototype.getSizeVertical = function() { return this.width + &quot;x&quot; + this.height; }; ImageProperties.prototype.getSizeHorizontal = function() { return this.height + &quot;x&quot; + this.width; }; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"q-utils_lib_qUtils.js.html":{"id":"q-utils_lib_qUtils.js.html","title":"Source: q-utils/lib/qUtils.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: q-utils/lib/qUtils.js /** * This module enhances the promise library 'Q' with further functionality. * @module q-utils * * @example * const Q = require('q'); * require('q-utils'); //no need to assign a variable since the additional methods are available through the 'Q' variable */ const Q = require('q'); /** * This method iterates over an array of value elements and executes the given function on each element of the array. * This method is used, when the order in which the elements get processed matters. The method ensures that Q-promise * waits for each element to be processed before it continues with the next one. The downside is that this util isn't * that it isn't as effective as other methods like _Q.all_. * @param {Object[]} dataArray - The data array which will be processed sequentially * @param {Function} functionToBeApplied - The function which will be called for each array element. The first parameter contains the array element and the second one the index of the element. The method has to return a promise. * @returns {promise} which resolves when the last element of the array is processed * * @example * const Q = require('q'); * require('q-utils'); * * let someChars = ['a', 'b', 'c', 'd', 'e']; * let logData = function(element, index) { * const deferred = Q.defer(); * console.log(element + ' at position ' + index); * deferred.resolve(); * return deferred.promise; * } * * Q.sequenceArray(someChars, logData).then(function(){ * console.log('finished sequencing'); * }); * * // The output will be: * a at position 1 * b at position 2 * c at position 3 * d at position 4 * e at position 5 * finished sequencing * */ function sequenceArray(dataArray, functionToBeApplied) { let emptyPromise = Q(); return dataArray.reduce(function(lastPromise, arrayElement, index) { return lastPromise.then(function() { return functionToBeApplied(arrayElement, index); }); }, emptyPromise); } Q.sequenceArray = sequenceArray; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"string-utils_lib_stringUtils.js.html":{"id":"string-utils_lib_stringUtils.js.html","title":"Source: string-utils/lib/stringUtils.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: string-utils/lib/stringUtils.js /** @module string-utils */ 'use strict'; String.prototype.trim = function() { return this.replace(/^\\s+|\\s+$/, ''); }; String.prototype.fulltrim = function() { return this.replace(/(?:(?:^|\\n)\\s+|\\s+(?:$|\\n))/g, '').replace(/\\s+/g, ' '); }; String.prototype.startsWith = function(str) { return this.indexOf(str) == 0; }; String.prototype.endsWith = function(str) { return this.slice(-str.length) == str; }; String.prototype.contains = function(searchStr) { return this.indexOf(searchStr) != -1 }; String.prototype.lastSubstringBefore = function(seperator) { var seperatorPosition = this.lastIndexOf(seperator); if (seperatorPosition == -1) { return this; } else { return this.substr(0, seperatorPosition + seperator.length - 1) } }; String.prototype.substringBefore = function(seperator) { var seperatorPosition = this.indexOf(seperator); if (seperatorPosition == -1) { return this; } else { return this.substr(0, seperatorPosition + seperator.length - 1) } }; String.prototype.lastSubstringAfter = function(seperator) { var seperatorPosition = this.lastIndexOf(seperator); if (seperatorPosition == -1) { return this; } else { return this.substr(seperatorPosition + seperator.length) } }; String.prototype.substringAfter = function(seperator) { var seperatorPosition = this.indexOf(seperator); if (seperatorPosition == -1) { return null; } else { return this.substr(seperatorPosition + seperator.length) } }; String.prototype.substringBetween = function(seperatorStart, seperatorEnd) { let separatorStartPosition = this.indexOf(seperatorStart); let separatorEndPosition = this.indexOf(seperatorEnd); if (separatorStartPosition == -1) { return null; } else { return this.substring(seperatorStart.length, separatorEndPosition); } }; String.prototype.replaceAll = function(searchString, replaceWith) { return this.split(searchString).join(replaceWith) }; /** * Checks weather the parameter is a string or not * @param {String} stringValue value to be evaluated * @returns {boolean} true - parameter is a string; false - otherwise */ exports.isString = function(stringValue) { return stringValue != undefined &amp;&amp; stringValue != null &amp;&amp; stringValue instanceof String; }; /** * Checks weather the value is undefined, null, instance of a string and if the string contains values * @param {String} stringValue value to be evaluated * @returns {boolean} true - when the object is undefined, null, not a String or string has no values; false - when the string has characters */ exports.isEmpty = function(stringValue) { return stringValue == undefined || stringValue == null || stringValue instanceof String || stringValue.length == 0; }; /** * This function returns the inverse result then the 'isEmpty' function * @param {String} stringValue * @returns {boolean} true - when the string has characters; false - when the object is undefined, null, not a String or string has no values */ exports.isNotEmpty = function(stringValue) { return !exports.isEmpty(stringValue); }; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"repository-session_lib_repositorySession.js.html":{"id":"repository-session_lib_repositorySession.js.html","title":"Source: repository-session/lib/repositorySession.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: repository-session/lib/repositorySession.js 'use strict'; const Q = require('q'); const repositoryManager = require('repository-manager'); const secureResourceManager = require('./secureResourceManager.js'); class RepositorySession { /** * Creates a repository session based on the * @param {UserSession} userSession - The user session which is applied to evaluate if the user has access rights. */ constructor(userSession) { this.user = userSession; } createEmptyResource(pathInfo) { return repositoryManager.createEmptyResource(pathInfo); }; createResource(pathInfo) { return repositoryManager.createResource(pathInfo); }; resolve(pathInfo) { let deferred = Q.defer(); let sessionUser = this.user; repositoryManager.resolve(pathInfo).then(function(resource) { secureResourceManager.secureResource(resource, sessionUser).then(function(resource) { deferred.resolve(resource); }).fail(deferred.reject); }).fail(deferred.reject); return deferred.promise; }; } module.exports = RepositorySession; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"request-pathinfo_lib_requestPathInfo.js.html":{"id":"request-pathinfo_lib_requestPathInfo.js.html","title":"Source: request-pathinfo/lib/requestPathInfo.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: request-pathinfo/lib/requestPathInfo.js 'use strict'; require(&quot;string-utils&quot;); const http = require('http'); const url = require(&quot;url&quot;); const Cookies = require(&quot;cookies&quot;); const logger = require('dachshund-logger').getLogger(__filename); class RequestPathInfo { /** * Extracts information from the HTTP request to provide them in the further process on resolving resources or processing components * @param {ClientRequest|string|RequestPathInfo} request - In case the {@link ClientRequest} or string is passed, the information will be extracted and populated into the class members. In case a {@link RequestPathInfo} is passed, the reference will be cloned into this new referenced object */ constructor(request) { /** * Hostname (e.g. 'www.foo.bar') * @type {string} */ this.host = null; /** * TCP/IP Port Number (e.g. '80' for unencrypted requests, '443' for encrypted requests) * @type {number} */ this.port = null; /** * Method which is used in the request (e.g. GET, POST, HEAD, PUT, DELETE) * @type {string} */ this.method = null; /** * Full qualified URI (e.g. 'https://www.foo.bar/path/to/my/content.selector.html/suffix?foo=bar&amp;bar=foo') * @type {string} */ this.url = null; /** * Complete application path of the url including path, selector and extension (e.g. '/path/tp/my/content.selector.html') * @type {string} */ this.completePath = null; /** * Whole the application path which include everything behind the hostname up to the first dot (e.g. '/path/to/my/content') * @type {string} */ this.componentPath = null; /** * Selector string of the URI. Contains everything of the complete path between the first and the last dot of the completePath * @type {string} */ this.selector = null; /** * Contains the file extension which is located behind the last dot and before the suffix or request parameters * @type {string} */ this.extension = null; /** * The suffix is defined behind the extension and starts with a slash (e.g. '/path/tp/my/content.html/suffix/path' --&gt; '/suffix/path') * @type {string} */ this.suffix = null; /** * A map of all cookies which are passed on with the request * @type {Object.&lt;string,string&gt;} */ this.cookies = null; /** * A map of all parameters which are defined in the URI behinde the questionmark * @type {Object.&lt;string,string&gt;} */ this.parameters = {}; //Init Requesr Information this.init(request); } // Initiates the class and extracts the information from the given HTTP request parameter init(request) { if (request instanceof http.IncomingMessage) { extractRequestInfo(this, request); extractApplicationPath(this, request.url); } else if (typeof (request) == 'string' || request instanceof String) { extractApplicationPath(this, request); } else if (request instanceof RequestPathInfo) { request.clone(this); } else if (request != undefined &amp;&amp; request != null) { logger.debug(&quot;Cannot read data for [RequestPathInfo] from [&quot; + typeof (request) + &quot;]&quot;); } } /** * Creates a clone of the current requestPathInfo. This method is used to modify a cloned reference without affecting the origin * @param {RequestPathInfo|Object} [clonedPathInfo] will be used as reference for the clone * @returns {RequestPathInfo} with the cloned members from this reference */ clone(clonedPathInfo) { clonedPathInfo = clonedPathInfo || new RequestPathInfo(); for (let key in this) { clonedPathInfo[key] = this[key]; } return clonedPathInfo; } /** * @return a pretty print json object with the members of this class */ toString() { let objectData = { &quot;host&quot;: this.host, &quot;port&quot;: this.port, &quot;method&quot;: this.method, &quot;url&quot;: this.url, &quot;completePath&quot;: this.completePath, &quot;componentPath&quot;: this.componentPath, &quot;selector&quot;: this.selector, &quot;extension&quot;: this.extension, &quot;suffix&quot;: this.suffix, &quot;parameters&quot;: this.parameters }; return JSON.stringify(objectData, null, 2); } } module.exports = RequestPathInfo; const extractRequestInfo = function(pathInfo, request) { pathInfo.cookies = new Cookies(request); try { pathInfo.host = request.headers.host.substringBefore(&quot;:&quot;); pathInfo.port = request.headers.host.substringAfter(&quot;:&quot;); pathInfo.method = request.method; } catch (err) { logger.error(&quot;Error while extracting path info: &quot; + err); } }; const extractApplicationPath = function(pathInfo, requestURL) { try { let parsedUrl = url.parse(requestURL, true); pathInfo.url = requestURL; pathInfo.completePath = decodeURIComponent(requestURL.substringBefore(&quot;?&quot;) + &quot;&quot;); pathInfo.componentPath = pathInfo.completePath.match(/^(\\/.?[^\\/.]*)*/)[0] + &quot;&quot;; let urlAfterResource = pathInfo.completePath.lastSubstringAfter(&quot;.&quot;); pathInfo.parameters = parsedUrl.query; pathInfo.extension = urlAfterResource; let extensionHasSuffix = urlAfterResource.indexOf(&quot;/&quot;) != -1; if (extensionHasSuffix) { pathInfo.suffix = &quot;/&quot; + urlAfterResource.substringAfter(&quot;/&quot;); pathInfo.extension = urlAfterResource.substr(0, urlAfterResource.length - pathInfo.suffix.length); pathInfo.completePath = pathInfo.completePath.substr(0, pathInfo.completePath.length - pathInfo.suffix.length); } let extensionHasSelector = ((pathInfo.completePath.length - 1) &gt; (pathInfo.componentPath.length + pathInfo.extension.length)) if (extensionHasSelector) { pathInfo.selector = pathInfo.completePath.substringBetween(pathInfo.componentPath + &quot;.&quot;, &quot;.&quot; + pathInfo.extension); } } catch (err) { logger.error(&quot;Error while processing application path: &quot; + err.toString()); } }; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"resource-types_lib_resourceTypes.js.html":{"id":"resource-types_lib_resourceTypes.js.html","title":"Source: resource-types/lib/resourceTypes.js","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Source: resource-types/lib/resourceTypes.js /** * is an ENUM and represents the different resource types */ class ResourceTypes { constructor(name) { this.name = name; Object.freeze(this); } /** * Compare two {@link ResourceTypes} * @param otherResourceType other resource type to be compared * @returns {boolean} true: resource types are the same, false: otherwise */ equals(otherResourceType) { return otherResourceType instanceof ResourceTypes &amp;&amp; otherResourceType.name == this.name; } /** * Checks if the reference is {@link ResourceTypes.NOT_FOUND} * @returns {boolean} true - when the {@link ResourceTypes} is {@link ResourceTypes.NOT_FOUND} */ isNotFound() { return this.name === ResourceTypes.NOT_FOUND.name; } /** * Static method to check if a resource type is from type file * @param {ResourceTypes} resource - to be checked * @returns {boolean} true: when the {@link ResourceTypes} is {@link ResourceTypes.FILE} */ static isFile(resource) { return resource instanceof Object &amp;&amp; ResourceTypes.FILE.name === resource.type; }; /** * Static method to check if a resource type is from type resource * @param {ResourceTypes} resource - to be checked * @returns {boolean} true: when the {@link ResourceTypes} is {@link ResourceTypes.RESOURCE} */ static isResource(resource) { return resource instanceof Object &amp;&amp; ResourceTypes.RESOURCE.name === resource.type; }; } /** * Resource is a file * @type {ResourceTypes} */ ResourceTypes.FILE = new ResourceTypes('file'); /** * Resource is a resource * @type {ResourceTypes} */ ResourceTypes.RESOURCE = new ResourceTypes('resource'); /** * Resource couldn't be resolved because it cannot be found * @type {ResourceTypes} */ ResourceTypes.NOT_FOUND = new ResourceTypes('not-found'); //Freeze the object to prevent that it get's modified somewhere else Object.freeze(ResourceTypes); module.exports = ResourceTypes; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Modules Classes Component DachshundError LocalResource RepositorySession RequestPathInfo Resource ResourceTypes × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Classes Classes Component DachshundError LocalResource RepositorySession RequestPathInfo Resource ResourceTypes × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Tutorials Classes Component DachshundError LocalResource RepositorySession RequestPathInfo Resource ResourceTypes × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Dachshund WCMSDachshund is a fast and lightweight WCMS. It's goal is to provide a content centric WCMS with a transparent and structured REST API to access and modify its data. It is tailored to support state of the art web application development with HTML5, CSS3 and Javascript. Unstructured Content / Hierarchical RelationshipDachshund comes bundled with a content repository and the API to access it. So there is no need for an additional database. Everything you need is your local file system. As the web is unstructured our content is unstructured as well. There is no need of database design. As web pages and their content is hierarchical structured, the relationship between data elements - we call them resources - is defined in the same same way. ResourceA resource has always a parent resource and may have multiple child resources. Furthermore, each resource has properties which represent the specific information of the resource. The abstract class Resource and documents the members and the methods to access the resource information. REST APIEach resource can be referenced through it's path in the hierarchy. The access takes place by stating the resource path, which is usually a subpath of /content, directly behind the URL. To render the content, the representation of the content is stated in the extension. To get more flexibility on rendering differend kind of views one or multiple dot separated selectors can be defined between the resource path and the extension. The class RequestPathInfo documents the members and methods to access the information passed with the request. Component HandlingTo render a resource it requires a component which is able to generate the requested view. The component is referenced trough the property componentPath in the requested resource. During a request the content resource is loaded, the property componentPath is resolved to the component and both are processed to send the requested view in the response. Within the component Javascript or Jazz Templates can be defined to build the view. To utilize the development process components can be inherited and build upon each other. Component Script HandlerTo lookup the script which handles the request the URL part behind the first dot is evaluated. This part states the optional selector(s) and the the extension. Within the component the available files are filtered to build a best match between requested rendition and available script files. When no matching script can be found but inheritance is used, the lookup for a matching script is extended to the super component. The following parameter are matched: Selector(s) within the URI the HTTP request (see REST API) Extension of the URI in the HTTP request (see REST API) Method used in the HTTP request Best to worst match: &lt;selector(s)&gt;.&lt;extension&gt;.&lt;scriptExtension&gt; (e.g. detailView.html.jazz) &lt;selector(s)&gt;.&lt;scriptExtension&gt; (e.g. detailView.jazz) &lt;extension&gt;.&lt;scriptExtension&gt; (e.g. html.jazz) &lt;method&gt;.&lt;scriptExtension&gt; (e.g. GET.jazz) &lt;componentName&gt;.&lt;scriptExtension&gt; (e.g. homepage.jazz) The filtering is applied to the file name, while the script extension states how the script has to be processed like *.js for javascript files or *.jazz for html templates. Application Server Structure /apps (system as well as custom application code) /content (content for each site and their sub pages) /config (application configuration) /home/users (system users) /home/groups (system usergroups) /libs (Client side libraries for javascript, stylesheet frameworks or images) System Requirements Mac OS X or Linux (Theoretical Windows) Node.js including npm (Version 5.2 and greater) Internet access to clone Dachshund from git and to download 3rd party npm modules GIT Version Control System (command line client or some UI client; just in case you want to download or) SetupStep 1.1 - Download and Unpack ...All releases are listed here. Download the source code from https://github.com/dachshund-wcms/dachshund/releases and unpack it into your file system. Step 1.2 - ... or Clone Latest Version from GitHubUse your UI client and clone the repository https://github.com/dachshund-wcms/dachshund change to the flag version 2.0 or use a command line client. cd basepath/to/clone/dachshund git clone https://github.com/dachshund-wcms/dachshund.gitStep 2 - Finish installationOpen a command line window and change to the dachshund folder. There you have to download the dependencies with node package manager as they're defined in the package.json. cd path/to/dachshund npm installStartupDachshund provides two methods to be started as normal or as debug application from the shell. The difference is that with one method its possible to use remote debugging like node-inspector. The other one starts just the application and redirects the log output into a log file. Version History 2.0 - First publicly available version. It is contains the core of Dachshund and all functionality to build applications or rich frontend on top of it. REST API Resource Resolving and Managing Component Handling Basic Authentication and Authorization Central configuration framework Render HTML templates with Jazz templating engine Render CSS templates with Less Multilingual Support with i18n 1.0 - Was the first implementation which was a proof of concept and used only for internal implementations, it provided the same functionality as the first published version 2.0 but wasn't tested or documented in any kind WishlistEven when Dachshund reached the version 2.0 the current implementation provide primarily the core functionality for a WCMS. Authoring and administration web HTML5 frontend Functionality to replicate content between dachshund instances Functionality to use Dachshund with SAML and/or LDAP Possibility to use databases like MongoDB or CouchDB × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"Component.html":{"id":"Component.html","title":"Class: Component","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Class: Component Component new Component(req, res, pathInfo, contentResource, componentResource) A component is a bundle of data, logic and request information to process it and return the result in the response Parameters: Name Type Description req ClientRequest res ServerResponse pathInfo RequestPathInfo contentResource Resource the content resource which contains the data to be procssed componentResource Resource the component resource which which contains the logic to process the data Source: component/lib/Component.js, line 19 Members componentResource :Resource The component resource which is defined on the property Component.resource.properties.componentPath and which is aimed to process the content resource Type: Resource Source: component/lib/Component.js, line 50 pathInfo :RequestPathInfo Type: RequestPathInfo Source: component/lib/Component.js, line 38 req :ClientRequest Type: ClientRequest Source: component/lib/Component.js, line 23 res :ServerResponse Type: ServerResponse Source: component/lib/Component.js, line 28 resource :Resource The content resource which is assigned to be processed whith this component Type: Resource Source: component/lib/Component.js, line 44 session :RepositorySession Type: RepositorySession Source: component/lib/Component.js, line 33 superComponent :Component Parent component of this component Type: Component Source: component/lib/Component.js, line 56 Methods executeScript(scriptName, scriptExtension, parameter) Executes a script from the Component.componentResource or Component.superComponent Parameters: Name Type Argument Description scriptName string name of the script which shall be executed from Component.componentResource scriptExtension string &lt;optional&gt; file extension of the script parameter Array.&lt;Object&gt; &lt;optional&gt; additional parameters which are passed on to the script handler Source: component/lib/Component.js, line 66 Returns: resolves when the script is handled Type promise getDefaultScript() Look up the default script of the component. The default script matches with name of the component. Source: component/lib/Component.js, line 98 Returns: resolves the path string of the script inside the context of the application server Type promise resolveScript(scriptName, recursive, extension) Resolves script file from Component.componentResource or recursive from Component.superComponent.componentResource Parameters: Name Type Argument Description scriptName string name of the script which shall be executed from Component.componentResource recursive boolean true: if the script cannot be resolved in the Component.componentResource the search is continued with the Component.superComponent; false: the lookup is limited to the Component.componentResource see true case extension string &lt;optional&gt; file extension of the script Source: component/lib/Component.js, line 121 Returns: resolves the path of the script string inside the context of the application server Type promise × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"DachshundError.html":{"id":"DachshundError.html","title":"Class: DachshundError","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Class: DachshundError DachshundError new DachshundError(message, id, nestedError) Extended version of the standard Error to store more information of an error Parameters: Name Type Argument Description message string &lt;optional&gt; Describing error message id number ID of the error, to distinguish errors by their identifier nestedError DachshundError | Error nested error which is encapbsulated in this error Source: dachshund-error/lib/DachshundError.js, line 31 Example //Init promise const Q = require('q'); someFailingFunction() { let deferred = Q.defer(); let originError = new Error('The dog has eaten all the food'); // Can be returned by a promise deferred.reject(new DachshundError('No dog food left', 404, originError)); // or can be thrown in an exception throw(new DachshundError('No dog food left', 404, originError)); return deferred.promise; } × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"LocalResource.html":{"id":"LocalResource.html","title":"Class: LocalResource","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Class: LocalResource LocalResource The local resource represents a resource which is held in the local file systen. The physical element of a resourceis a folder in the file system. The files '.properties.json' and 'auth.json' contain the properties and authorizationinformation of the resource. It provides access to the child resources through the held sub-folders. The parentresource is the parent folder. The files in this folders can be access and modified as well. new LocalResource() Source: local-resource/lib/localResource.js, line 20 Extends Resource Members depth The level on which the path of the resource is located The root node has the depth of 0 The first level of child nodes has the depth 1 The path '/path/to/my/resource' has the depth 4 Inherited From: Resource#depth Source: resource/lib/resource.js, line 33 Methods addFile(sourceReadStream, filename) Adds a file to the resource Parameters: Name Type Description sourceReadStream stream to fill the file content filename sets the name of the file Inherited From: Resource#addFile Overrides: Resource#addFile Source: resource/lib/resource.js, line 100 Returns: resolves when the file is added to the resource Type promise deleteAllFiles(includeHiddenFiles) Deletes all files from this resource Parameters: Name Type Description includeHiddenFiles [includeHiddenFiles] - true: hidden files, starting with a dot (e.g. '.hiddenFile') will be included; false - otherwise (default) Inherited From: Resource#deleteAllFiles Overrides: Resource#deleteAllFiles Source: resource/lib/resource.js, line 90 Returns: Type promise deleteFile(filename) Checks weather a file exists or not and deletes it in case it exists Parameters: Name Type Description filename name of the file to be deleted Inherited From: Resource#deleteFile Overrides: Resource#deleteFile Source: resource/lib/resource.js, line 81 Returns: resolves with true when the file existed and is deleted; false when the file didn't existed Type promise fileExists(filename) Checks weather a files exists or not Parameters: Name Type Description filename name of the file to be checked Inherited From: Resource#fileExists Overrides: Resource#fileExists Source: resource/lib/resource.js, line 72 Returns: resolves with true when the file exists and false otherwise Type promise getAbsoluteParentResource(depth) Provides an absolute parent of this resource Parameters: Name Type Description depth number number of depth of the requested parent resource; the number has be greate then 0 and smaller then it's own depth Inherited From: Resource#getAbsoluteParentResource Overrides: Resource#getAbsoluteParentResource Source: resource/lib/resource.js, line 142 Returns: resolves with the Resource which represents the absolute parent of this resource Type promise getChildResources() Provides a list of childs resources belonging to this resource Inherited From: Resource#getChildResources Overrides: Resource#getChildResources Source: resource/lib/resource.js, line 125 Returns: resolves with a list Resource[] of child resources belonging to this resource Type promise getChilds() Provides a list of childs belonging to this resource Inherited From: Resource#getChilds Overrides: Resource#getChilds Source: resource/lib/resource.js, line 117 Returns: resolves with a list string[] of childs belonging to this resource Type promise getData() Provides the data of this resource Inherited From: Resource#getData Source: resource/lib/resource.js, line 191 Returns: Type Object getFiles(includeHiddenFiles) Provides a list of files which belong to this resource Parameters: Name Type Argument Description includeHiddenFiles boolean &lt;optional&gt; true: hidden files, starting with a dot (e.g. '.hiddenFile') will be included; false - otherwise (default) Inherited From: Resource#getFiles Overrides: Resource#getFiles Source: resource/lib/resource.js, line 63 Returns: resolves with a list of files string[] which belong to this resource Type promise getHiddenResourceChilds() Provides a list of all hidden child nodes represented as a Resource. To be a hidden child node thechild node name has to start with a dot (e.g. '.hiddenChildNode') Inherited From: Resource#getHiddenResourceChilds Overrides: Resource#getHiddenResourceChilds Source: resource/lib/resource.js, line 151 Returns: resolves with a list Resource[] of child resources belonging to this resource Type promise getParentResource() Provides the parent resource of this resource Inherited From: Resource#getParentResource Overrides: Resource#getParentResource Source: resource/lib/resource.js, line 133 Returns: resolves with the Resource which represents the parent of this resource Type promise getProperty(name, defaultValue) Reads a property which belong to the resource Parameters: Name Type Argument Description name String name of the property which shall be read defaultValue * &lt;optional&gt; will be return in the case that the property isn't defined Inherited From: Resource#getProperty Source: resource/lib/resource.js, line 48 Returns: the value of the property or the default value when it's defined and the property isn't set Type * loadAuthorization() Loads the authorization properties which define the access rights to this resource. Inherited From: Resource#loadAuthorization Overrides: Resource#loadAuthorization Source: resource/lib/resource.js, line 175 Returns: resolves when the authorization properties are loaded Type promise loadProperties() Loads ths properties of this resource which can be access through the member properties Inherited From: Resource#loadProperties Overrides: Resource#loadProperties Source: resource/lib/resource.js, line 159 Returns: resolves when the properties are loaded Type promise loadScript(scriptName) Loads a script from the resource with the node.js require method Parameters: Name Type Description scriptName name of the script to loaded Inherited From: Resource#loadScript Overrides: Resource#loadScript Source: resource/lib/resource.js, line 109 Returns: resolves with the loaded script Type promise saveAuthorization() Persists changes which were made to the class member auth Inherited From: Resource#saveAuthorization Overrides: Resource#saveAuthorization Source: resource/lib/resource.js, line 183 Returns: resolves when the authorization properties are saved Type promise saveProperties() Persists changes which were made to the class member properties Inherited From: Resource#saveProperties Overrides: Resource#saveProperties Source: resource/lib/resource.js, line 167 Returns: resolves when the properties are saved Type promise × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"module-authentication-handler-basic-auth.html":{"id":"module-authentication-handler-basic-auth.html","title":"Module: authentication-handler-basic-auth","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Module: authentication-handler-basic-auth Source: authentication-handler-basic-auth/lib/authenticationHandlerBasicAuth.js, line 1 Methods &lt;inner&gt; authenticationHeaderIsSet(req) Checks weather the authorization header is set in the http request Parameters: Name Type Description req http request object Source: authentication-handler-basic-auth/lib/authenticationHandlerBasicAuth.js, line 37 Returns: true - when header is set | false - otherwise Type boolean &lt;inner&gt; extractCredentials(req) Extract basic authentication header from http request object Parameters: Name Type Description req Object http request object Source: authentication-handler-basic-auth/lib/authenticationHandlerBasicAuth.js, line 18 Returns: Type Object × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"module-component-handler_componentHandler.html":{"id":"module-component-handler_componentHandler.html","title":"Module: component-handler/componentHandler","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Module: component-handler/componentHandler Source: component-handler/lib/componentHandler.js, line 1 Methods &lt;static&gt; getScriptToHandle(component, prefix) Lookup a matching script which is able to handle the request with the speicifed selector and extension in the RequestPathInfo Parameters: Name Type Description component Component with the enclosed request information prefix string will be set in front of the script file name to resolve a possible match Source: component-handler/lib/componentHandler.js, line 52 Returns: which resolves with the scriptPath {string} Type promise &lt;static&gt; handle(component) Processes the component by looking up the script which is matches to the request and to execute the script Parameters: Name Type Description component Component The component to be handled with the enclosed request information Source: component-handler/lib/componentHandler.js, line 16 Returns: resolved when a script could be resolved and executed Type promise × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"module-component-handler_componentLoader.html":{"id":"module-component-handler_componentLoader.html","title":"Module: component-handler/componentLoader","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Module: component-handler/componentLoader Source: component-handler/lib/componentLoader.js, line 1 Methods &lt;static&gt; load(req, res, pathInfo, contentResource, componentResource) Loads a components and initialized with the parameters passed in the function parameters. Furthermore it loadsthe recursively all super components in case its defined. Parameters: Name Type Description req ClientRequest res ServerResponse pathInfo RequestPathInfo contentResource Resource componentResource Resource Source: component-handler/lib/componentLoader.js, line 21 Returns: resolves with the Component Type promise × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"module-component-handler_dispatcher.html":{"id":"module-component-handler_dispatcher.html","title":"Module: component-handler/dispatcher","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Module: component-handler/dispatcher Source: component-handler/lib/dispatcher.js, line 1 Methods &lt;static&gt; complete(res, pathInfo, data) Called when component is processed and the result shall be send within the response Parameters: Name Type Description res ServerResponse Response to which the data shall be send pathInfo RequestPathInfo To resolve the mime type from the requested file extension data string processed data to be passed back in the HTTP response Source: component-handler/lib/dispatcher.js, line 21 &lt;static&gt; dispatchRequest(req, res, pathInfo, contentResource) Dispatched the HTTP request Parameters: Name Type Description req ClientRequest res ServerResponse pathInfo RequestPathInfo contentResource Resource Source: component-handler/lib/dispatcher.js, line 63 &lt;static&gt; fail(res, data) Called when something went wrong while processing the component. It ends the request properly and providesfurther information why the request failed Parameters: Name Type Description res ServerResponse Response to which the data shall be send data string | Error error message which is send back in the HTTP response Source: component-handler/lib/dispatcher.js, line 36 × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"module-component-handler_prepareScriptHandler.html":{"id":"module-component-handler_prepareScriptHandler.html","title":"Module: component-handler/prepareScriptHandler","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Module: component-handler/prepareScriptHandler Source: component-handler/lib/prepareScriptHandler.js, line 1 Members &lt;inner, constant&gt; ELEMENT_NOT_FOUND :number Type: number Source: component-handler/lib/prepareScriptHandler.js, line 12 Methods &lt;static&gt; resolveAndHandle(component) A component resource may have a file called 'prepare.js'. This file is executed prior to the component script whichis lookup up based on the RequestPathInfo. The prepare script is able to enhance the component and enclosedresource with further information which processed during runtime. Parameters: Name Type Description component component as base to lookup the prepare script of this and all super components Source: component-handler/lib/prepareScriptHandler.js, line 22 Returns: resolves when no prepare could be found or all found prepare scripts are executed succesful Type promise × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"module-component-script-handler_jazzHandler.html":{"id":"module-component-script-handler_jazzHandler.html","title":"Module: component-script-handler/jazzHandler","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Module: component-script-handler/jazzHandler The Jazz handler handles all HTML templates with the file extension *.jazz. The source and documentation of the templating engine can be found here https://github.com/shinetech/jazz. The templating engine makes it possible to write html code and to enhance it with place holder, conditions, loops and further predefined javascript methods. Since this handle is executed in a context of a component, it provides access to resource its properties but also to include further scripts from component resource or to include other resources. In addition to the standard functions defined in the jazz documentation the following additional functioanlity is provided: Access Content Resource PropertyHello {properties.yourFirstName} you age is {properties.age} &lt;!-- Access a property from the resource of the component trough a method --&gt; &lt;!-- define a default value, which is uses in case the property doesn't exists --&gt; Hello {getProperty('yourName', 'John Doe')} you age is {getProperty('age', 42)}Conditional Statements{if properties.yourFirstName} Hello, {properties.yourFirstName} {end} &lt;!-- with else clause --&gt; {if properties.yourFirstName} Hello, {properties.yourFirstName} {else} Hello Anonymous {end} &lt;!-- or with else if --&gt; {if properties.yourFirstName} Hello, {properties.yourFirstName} {elif properties.yourLastName} Hello, Mr. {properties.yourLastName} {else} Hello Anonymous {end} &lt;!-- with logical expressions --&gt; {if properties.yourFirstName and properties.yourLastName} Hello {properties.yourFirstName} {properties.yourLastName} {end} {if properties.usesATablet or properties.usesASmartphone} You access the site with a mobile device. {end} {if not properties.driversLicence} You are not allowed to drive a car. {end} &lt;!-- comparing two values with eq (equals) or neq (not equals) --&gt; {if properties.gender eq 'male'} Hello, Mr. {properties.yourLastName} {end} {if properties.status neq 'offline'} You're online! {end}Looping Over an Object{foreach childPage in properties.chilePages} &lt;p&gt;&lt;a href='{childPage.path}.html'&gt;{childPage.name}&lt;/a&gt;&lt;/p&gt; {end} &lt;!-- using counters / index --&gt; {foreach childPage in properties.chilePages} &lt;p&gt;&lt;a href='{childPage.path}.html'&gt;{childPage.name}&lt;/a&gt;&lt;/p&gt; &lt;p&gt;Loop number (1 based): {__count}&lt;/p&gt; &lt;p&gt;Index (0 based): {__index}&lt;/p&gt; {end}Include Script from Component ResourceThe result will be added into the calling jazz file. The execution takes place in the same context. {includeScript('nameOfTheOtherScriptInComponentResource.jazz')}Include Components &lt;!-- The path can be relative or absolute. --&gt; {includeComponent('footer')} {includeComponent('./footer')} {includeComponent('../parentPath')} {includeComponent('/complete/path/to/other/contentResource')} &lt;!-- It is also possible to define the component resource which shall be taken. In this case the defined --&gt; &lt;!-- 'resourcePath' property on the content resource will be ignored --&gt; {includeComponent('footer', '/apps/myApp/footer')} &lt;!-- When the component provides different renditions depending on the selector, the selector can be passed on --&gt; &lt;!-- as well, to provide for example overview, detail or edit view with one component --&gt; {includeComponent('footer', '/apps/myApp/footer', 'compact')}`Further Utility Functions&lt;!-- Furthermore some methods are provided to utilize the templating process --&gt; &lt;!-- Use translation with nodejs module i18n --&gt; {i18n(variableOrStringToBeTranslated)} &lt;!-- Check if in an element from an array is the last one, returns true if this is the case --&gt; {isLastElement(arrayToBeChecked, elementFromArray)} &lt;!-- Negates an boolean value --&gt; {isNot(booleanVariable)} &lt;!-- Checks if a variable is undefined and return true if this th case --&gt; {isUndefined(variableToBeChecked)} &lt;!-- Checks if a variable is defined returns true if this is the case --&gt; {isDefined(variableToBeChecked)} &lt;!-- Escapes special charactors in a string --&gt; {escape(stringToBeEscaped)}` Source: component-script-handler/lib/componentScriptHandler/jazzHandler.js, line 1 × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"module-componentScriptHandler.html":{"id":"module-componentScriptHandler.html","title":"Module: componentScriptHandler","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Module: componentScriptHandler The component script handler contains all methods to handle files defined in the component resource. The scripthandler are held in the folder './componentScriptHandler' and are responsible to manage files with differentfile extensions. Currently the following script handler are defined: Javascript Handler Handles all script files with the file extension *.js Jazz Handler Handles all jazz template files with the file extension *.jazz LessCSS Handler Handles all less css files with the file extension *.less Static Handler Handles all files with the file extension *.static Source: component-script-handler/lib/componentScriptHandler.js, line 1 × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"module-dachshund-logger.html":{"id":"module-dachshund-logger.html","title":"Module: dachshund-logger","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Module: dachshund-logger Source: dachshund-logger/lib/DachshundLogger.js, line 1 Methods &lt;static&gt; getLogger(filename) Creates a logger which wraps the log4js logger https://www.npmjs.com/package/log4js Parameters: Name Type Description filename Filename as it is given by the __filename environment variable Source: dachshund-logger/lib/DachshundLogger.js, line 24 Example //Include logger in node.js module const logger = require('dachshund-logger').getLogger(__filename); //Use logge in node.js module logger.trace('Trace message'); logger.debug('Debug message'); logger.info('Info message'); logger.warn('Warn message'); logger.error('Error message'); logger.fatal('Fatal message'); × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"module-file-script-handler_imageDimensionsHandler.html":{"id":"module-file-script-handler_imageDimensionsHandler.html","title":"Module: file-script-handler/imageDimensionsHandler","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Module: file-script-handler/imageDimensionsHandler Source: file-script-handler/lib/fileScriptHandler/imageDimensionsHandler.js, line 1 × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"module-file-script-handler_imageExifHandler.html":{"id":"module-file-script-handler_imageExifHandler.html","title":"Module: file-script-handler/imageExifHandler","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Module: file-script-handler/imageExifHandler Source: file-script-handler/lib/fileScriptHandler/imageExifHandler.js, line 1 × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"module-file-script-handler_imageSizeHandler.html":{"id":"module-file-script-handler_imageSizeHandler.html","title":"Module: file-script-handler/imageSizeHandler","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Module: file-script-handler/imageSizeHandler Source: file-script-handler/lib/fileScriptHandler/imageSizeHandler.js, line 1 Methods &lt;inner&gt; createThumbnail(thumbProperties) Creates the thumbnail and stores it at the parent resource where the original image belongs to Parameters: Name Type Description thumbProperties ImageProperties Information about the thumbnail process Source: file-script-handler/lib/fileScriptHandler/imageSizeHandler.js, line 106 Returns: Type * &lt;inner&gt; ImageProperties(pathInfo) Resolves the necessary parameters to create the image thumbnail Parameters: Name Type Description pathInfo RequestPathInfo object resolved from the http request Source: file-script-handler/lib/fileScriptHandler/imageSizeHandler.js, line 176 × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"module-q-utils.html":{"id":"module-q-utils.html","title":"Module: q-utils","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Module: q-utils This module enhances the promise library 'Q' with further functionality. Source: q-utils/lib/qUtils.js, line 1 Example const Q = require('q'); require('q-utils'); //no need to assign a variable since the additional methods are available through the 'Q' variable Methods &lt;inner&gt; sequenceArray(dataArray, functionToBeApplied) This method iterates over an array of value elements and executes the given function on each element of the array.This method is used, when the order in which the elements get processed matters. The method ensures that Q-promisewaits for each element to be processed before it continues with the next one. The downside is that this util isn'tthat it isn't as effective as other methods like Q.all. Parameters: Name Type Description dataArray Array.&lt;Object&gt; The data array which will be processed sequentially functionToBeApplied function The function which will be called for each array element. The first parameter contains the array element and the second one the index of the element. The method has to return a promise. Source: q-utils/lib/qUtils.js, line 45 Returns: which resolves when the last element of the array is processed Type promise Example const Q = require('q'); require('q-utils'); let someChars = ['a', 'b', 'c', 'd', 'e']; let logData = function(element, index) { const deferred = Q.defer(); console.log(element + ' at position ' + index); deferred.resolve(); return deferred.promise; } Q.sequenceArray(someChars, logData).then(function(){ console.log('finished sequencing'); }); // The output will be: a at position 1 b at position 2 c at position 3 d at position 4 e at position 5 finished sequencing × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"module-string-utils.html":{"id":"module-string-utils.html","title":"Module: string-utils","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Module: string-utils Source: string-utils/lib/stringUtils.js, line 1 Methods &lt;static&gt; isEmpty(stringValue) Checks weather the value is undefined, null, instance of a string and if the string contains values Parameters: Name Type Description stringValue String value to be evaluated Source: string-utils/lib/stringUtils.js, line 103 Returns: true - when the object is undefined, null, not a String or string has no values; false - when the string has characters Type boolean &lt;static&gt; isNotEmpty(stringValue) This function returns the inverse result then the 'isEmpty' function Parameters: Name Type Description stringValue String Source: string-utils/lib/stringUtils.js, line 112 Returns: true - when the string has characters; false - when the object is undefined, null, not a String or string has no values Type boolean &lt;static&gt; isString(stringValue) Checks weather the parameter is a string or not Parameters: Name Type Description stringValue String value to be evaluated Source: string-utils/lib/stringUtils.js, line 94 Returns: true - parameter is a string; false - otherwise Type boolean × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"RepositorySession.html":{"id":"RepositorySession.html","title":"Class: RepositorySession","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Class: RepositorySession RepositorySession new RepositorySession(userSession) Creates a repository session based on the Parameters: Name Type Description userSession UserSession The user session which is applied to evaluate if the user has access rights. Source: repository-session/lib/repositorySession.js, line 13 × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"RequestPathInfo.html":{"id":"RequestPathInfo.html","title":"Class: RequestPathInfo","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Class: RequestPathInfo RequestPathInfo new RequestPathInfo(request) Extracts information from the HTTP request to provide them in the further process on resolving resources or processing components Parameters: Name Type Description request ClientRequest | string | RequestPathInfo In case the ClientRequest or string is passed, the information will be extracted and populated into the class members. In case a RequestPathInfo is passed, the reference will be cloned into this new referenced object Source: request-pathinfo/lib/requestPathInfo.js, line 16 Members completePath :string Complete application path of the url including path, selector and extension (e.g. '/path/tp/my/content.selector.html') Type: string Source: request-pathinfo/lib/requestPathInfo.js, line 45 componentPath :string Whole the application path which include everything behind the hostname up to the first dot (e.g. '/path/to/my/content') Type: string Source: request-pathinfo/lib/requestPathInfo.js, line 51 cookies :Object.&lt;string, string&gt; A map of all cookies which are passed on with the request Type: Object.&lt;string, string&gt; Source: request-pathinfo/lib/requestPathInfo.js, line 75 extension :string Contains the file extension which is located behind the last dot and before the suffix or request parameters Type: string Source: request-pathinfo/lib/requestPathInfo.js, line 63 host :string Hostname (e.g. 'www.foo.bar') Type: string Source: request-pathinfo/lib/requestPathInfo.js, line 21 method :string Method which is used in the request (e.g. GET, POST, HEAD, PUT, DELETE) Type: string Source: request-pathinfo/lib/requestPathInfo.js, line 33 parameters :Object.&lt;string, string&gt; A map of all parameters which are defined in the URI behinde the questionmark Type: Object.&lt;string, string&gt; Source: request-pathinfo/lib/requestPathInfo.js, line 81 port :number TCP/IP Port Number (e.g. '80' for unencrypted requests, '443' for encrypted requests) Type: number Source: request-pathinfo/lib/requestPathInfo.js, line 27 selector :string Selector string of the URI. Contains everything of the complete path between the first and the last dot of the completePath Type: string Source: request-pathinfo/lib/requestPathInfo.js, line 57 suffix :string The suffix is defined behind the extension and starts with a slash (e.g. '/path/tp/my/content.html/suffix/path' --&gt; '/suffix/path') Type: string Source: request-pathinfo/lib/requestPathInfo.js, line 69 url :string Full qualified URI (e.g. 'https://www.foo.bar/path/to/my/content.selector.html/suffix?foo=bar&amp;bar=foo') Type: string Source: request-pathinfo/lib/requestPathInfo.js, line 39 Methods clone(clonedPathInfo) Creates a clone of the current requestPathInfo. This method is used to modify a cloned reference without affecting the origin Parameters: Name Type Argument Description clonedPathInfo RequestPathInfo | Object &lt;optional&gt; will be used as reference for the clone Source: request-pathinfo/lib/requestPathInfo.js, line 113 Returns: with the cloned members from this reference Type RequestPathInfo toString() Source: request-pathinfo/lib/requestPathInfo.js, line 127 Returns: a pretty print json object with the members of this class × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"Resource.html":{"id":"Resource.html","title":"Class: Resource","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Class: Resource Resource new Resource() Resource is an element of hierarchical structure. It has one parent resource and may have multiple childresources. Furthermore a resource can contain files and properties which can be accessed or modified. The IDof each resource is represented by it's path and can be referenced trough it. Source: resource/lib/resource.js, line 14 Members depth The level on which the path of the resource is located The root node has the depth of 0 The first level of child nodes has the depth 1 The path '/path/to/my/resource' has the depth 4 Source: resource/lib/resource.js, line 33 Methods addFile(sourceReadStream, filename) Adds a file to the resource Parameters: Name Type Description sourceReadStream stream to fill the file content filename sets the name of the file Source: resource/lib/resource.js, line 100 Returns: resolves when the file is added to the resource Type promise deleteAllFiles(includeHiddenFiles) Deletes all files from this resource Parameters: Name Type Description includeHiddenFiles [includeHiddenFiles] - true: hidden files, starting with a dot (e.g. '.hiddenFile') will be included; false - otherwise (default) Source: resource/lib/resource.js, line 90 Returns: Type promise deleteFile(filename) Checks weather a file exists or not and deletes it in case it exists Parameters: Name Type Description filename name of the file to be deleted Source: resource/lib/resource.js, line 81 Returns: resolves with true when the file existed and is deleted; false when the file didn't existed Type promise fileExists(filename) Checks weather a files exists or not Parameters: Name Type Description filename name of the file to be checked Source: resource/lib/resource.js, line 72 Returns: resolves with true when the file exists and false otherwise Type promise getAbsoluteParentResource(depth) Provides an absolute parent of this resource Parameters: Name Type Description depth number number of depth of the requested parent resource; the number has be greate then 0 and smaller then it's own depth Source: resource/lib/resource.js, line 142 Returns: resolves with the Resource which represents the absolute parent of this resource Type promise getChildResources() Provides a list of childs resources belonging to this resource Source: resource/lib/resource.js, line 125 Returns: resolves with a list Resource[] of child resources belonging to this resource Type promise getChilds() Provides a list of childs belonging to this resource Source: resource/lib/resource.js, line 117 Returns: resolves with a list string[] of childs belonging to this resource Type promise getData() Provides the data of this resource Source: resource/lib/resource.js, line 191 Returns: Type Object getFiles(includeHiddenFiles) Provides a list of files which belong to this resource Parameters: Name Type Argument Description includeHiddenFiles boolean &lt;optional&gt; true: hidden files, starting with a dot (e.g. '.hiddenFile') will be included; false - otherwise (default) Source: resource/lib/resource.js, line 63 Returns: resolves with a list of files string[] which belong to this resource Type promise getHiddenResourceChilds() Provides a list of all hidden child nodes represented as a Resource. To be a hidden child node thechild node name has to start with a dot (e.g. '.hiddenChildNode') Source: resource/lib/resource.js, line 151 Returns: resolves with a list Resource[] of child resources belonging to this resource Type promise getParentResource() Provides the parent resource of this resource Source: resource/lib/resource.js, line 133 Returns: resolves with the Resource which represents the parent of this resource Type promise getProperty(name, defaultValue) Reads a property which belong to the resource Parameters: Name Type Argument Description name String name of the property which shall be read defaultValue * &lt;optional&gt; will be return in the case that the property isn't defined Source: resource/lib/resource.js, line 48 Returns: the value of the property or the default value when it's defined and the property isn't set Type * loadAuthorization() Loads the authorization properties which define the access rights to this resource. Source: resource/lib/resource.js, line 175 Returns: resolves when the authorization properties are loaded Type promise loadProperties() Loads ths properties of this resource which can be access through the member properties Source: resource/lib/resource.js, line 159 Returns: resolves when the properties are loaded Type promise loadScript(scriptName) Loads a script from the resource with the node.js require method Parameters: Name Type Description scriptName name of the script to loaded Source: resource/lib/resource.js, line 109 Returns: resolves with the loaded script Type promise saveAuthorization() Persists changes which were made to the class member auth Source: resource/lib/resource.js, line 183 Returns: resolves when the authorization properties are saved Type promise saveProperties() Persists changes which were made to the class member properties Source: resource/lib/resource.js, line 167 Returns: resolves when the properties are saved Type promise × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"ResourceTypes.html":{"id":"ResourceTypes.html","title":"Class: ResourceTypes","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Class: ResourceTypes ResourceTypes is an ENUM and represents the different resource types new ResourceTypes() Source: resource-types/lib/resourceTypes.js, line 4 Members &lt;static&gt; FILE :ResourceTypes Resource is a file Type: ResourceTypes Source: resource-types/lib/resourceTypes.js, line 52 &lt;static&gt; NOT_FOUND :ResourceTypes Resource couldn't be resolved because it cannot be found Type: ResourceTypes Source: resource-types/lib/resourceTypes.js, line 64 &lt;static&gt; RESOURCE :ResourceTypes Resource is a resource Type: ResourceTypes Source: resource-types/lib/resourceTypes.js, line 58 Methods &lt;static&gt; isFile(resource) Static method to check if a resource type is from type file Parameters: Name Type Description resource ResourceTypes to be checked Source: resource-types/lib/resourceTypes.js, line 34 Returns: true: when the ResourceTypes is ResourceTypes.FILE Type boolean &lt;static&gt; isResource(resource) Static method to check if a resource type is from type resource Parameters: Name Type Description resource ResourceTypes to be checked Source: resource-types/lib/resourceTypes.js, line 43 Returns: true: when the ResourceTypes is ResourceTypes.RESOURCE Type boolean equals(otherResourceType) Compare two ResourceTypes Parameters: Name Type Description otherResourceType other resource type to be compared Source: resource-types/lib/resourceTypes.js, line 17 Returns: true: resource types are the same, false: otherwise Type boolean isNotFound() Checks if the reference is ResourceTypes.NOT_FOUND Source: resource-types/lib/resourceTypes.js, line 25 Returns: true - when the ResourceTypes is ResourceTypes.NOT_FOUND Type boolean × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "},"tutorial-Development Tutorial.html":{"id":"tutorial-Development Tutorial.html","title":"Tutorial: Development Tutorial","body":" Dachshund Modules authentication-handler-basic-authcomponent-handler/componentHandlercomponent-handler/componentLoadercomponent-handler/dispatchercomponent-handler/prepareScriptHandlercomponent-script-handler/jazzHandlercomponentScriptHandlerdachshund-loggerfile-script-handler/imageDimensionsHandlerfile-script-handler/imageExifHandlerfile-script-handler/imageSizeHandlerq-utilsstring-utils Classes ComponentDachshundErrorLocalResourceRepositorySessionRequestPathInfoResourceResourceTypes Tutorials Development Tutorial Development Tutorial 1 - Create Hello World ExampleTo start with a new site, the required folder structure has to be created first. Dachshund splits application logic and content, so both parts have to be defined in order to access our first application. 1.1 - Create Content ResourceCreate the folder /content/helloWorld and create within a new file called .properties.json. The content has to be: { &quot;componentPath&quot;: &quot;/apps/helloWorld/pageComponents/helloWorld&quot;, &quot;title&quot;: &quot;Hello World&quot;, &quot;description&quot;: &quot;This is my first Web Page with dachshund&quot; }1.2 - Create Component ResourceCreate the folder /apps/helloWorld/pageComponents/helloWorld and create within a new file called helloWorld.jazz. The content has to be: &lt;html&gt; &lt;head&gt; &lt;title&gt;{properties.title}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;{properties.title}&lt;/h1&gt; &lt;p&gt;{properties.description}&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;Finally start Dachshund and access http://localhost:8888/content/helloWorld.html. You should see the rendered web page filled with the properties defined in the content resource. 2 - Organize Component ResourceOur component resource consists at the moment out of one file. It's so simple that organizing it in multiple file doesn't really make sense, but usually components are way more complex and organizing them in different files helps maintaining them. Furthermore it will utilize component inheritance later on. Within the folder /apps/helloWorld/pageComponents/helloWorld create the file head.jazz with the content: &lt;head&gt; &lt;title&gt;{properties.title}&lt;/title&gt; &lt;/head&gt;and a file called body.jazz with the content: &lt;body&gt; &lt;h1&gt;{properties.title}&lt;/h1&gt; &lt;p&gt;{properties.description}&lt;/p&gt; &lt;/body&gt;finally we change the helloWorld.jazz and replace the current content with the {includeScript('templateFile.jazz')} statements. &lt;html&gt; {includeScript('head.jazz')} {includeScript('body.jazz')} &lt;/html&gt;When we access http://localhost:8888/content/helloWorld.html with the running Dachshund server, we should see the rendered web page as it was in the previous exercise. Change the title and description properties in /content/helloWorld/.properties.json and reload the page to see if the changes get applied. 3 - Use component InheritanceComponents can be build upon each other by using inheritance. As OOP with classes makes it possible to override methods with Dachshund it's possible to override scripts in Dachshund components. When scripts are included with {includeScript('myFile.jazz')} the script will be looked up along the inheritance chain of components and the first match is included. To use inheritance we have to define the suprt component within our component. Within the folder /apps/helloWorld/pageComponents/helloWorld create the file .properties.json with the content: { &quot;superComponent&quot;: &quot;/apps/core/components/page&quot; }Now the page component inherits the page component which is part of the core components from Dachshund. The advantage is that basic functionality can be reused and functionality for the purpose of the particular component is overwritten. For our example the files helloWorld.jazz and head.jazz can be deleted. Reload http://localhost:8888/content/helloWorld.html to check that the page still works. The head.jazz is already defined in the super component. When we want to adjust stylesheets or scripts which are included in the head, we can create a headScripts.jazz or headStyles.jazz in our helloWorld component to do the adjustments for our website in there. The demo application Hello Dachshund shows how pages can be build on top of each other. The component /apps/helloDachshund/pageComponents/contentPage is inherited from the component homePage in the same folder. It overrides the content.jazz to define the page component specific logic. 4 - Create and Include Other ComponentsA website is usually subdivided into smaller functional blocks which we want to control and develop independently. To archive this the component model can be applied to page fragments as well. 4.1 - Create Content ResourcesCreate the folder /content/helloWorld/.content/contacts/johnDoe and create within a new file called .properties.json. The content has to be: { &quot;componentPath&quot;: &quot;/apps/helloWorld/components/contactData&quot;, &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Doe&quot;, &quot;gender&quot;: &quot;male&quot;, &quot;age&quot;: 42, &quot;street&quot;: &quot;John Dorian Lane 42&quot;, &quot;city&quot;: &quot;Virtuopolis&quot;, &quot;postalCode&quot;: &quot;123456&quot; }Create the folder /content/helloWorld/.content/contacts/janeDoe and create within a new file called .properties.json. The content has to be: { &quot;componentPath&quot;: &quot;/apps/helloWorld/components/contactData&quot;, &quot;firstName&quot;: &quot;Jane&quot;, &quot;lastName&quot;: &quot;Doe&quot;, &quot;gender&quot;: &quot;female&quot;, &quot;age&quot;: 24, &quot;street&quot;: &quot;John Dorian Lane 42&quot;, &quot;city&quot;: &quot;Virtuopolis&quot;, &quot;postalCode&quot;: &quot;123456&quot; }4.2 - Create Component ResourceCreate the folder /apps/helloWorld/components/contactData and create within a new file called contactData.jazz. The content has to be: &lt;address&gt; &lt;h2&gt;{properties.firstName} {properties.lastName} ({properties.age})&lt;/h2&gt; &lt;div&gt;{properties.street}&lt;/div&gt; &lt;div&gt;{properties.postalCode} {properties.city}&lt;/div&gt; &lt;/address&gt;4.3 - Include Component in the Page ComponentOpen the body.jazz from /apps/helloWorld/pageComponents/helloWorld and add the {includeComponent('pathToComponent')} statements to add the component at this point. After the modification the file should look like this: &lt;body&gt; &lt;h1&gt;{properties.title}&lt;/h1&gt; &lt;p&gt;{properties.description}&lt;/p&gt; &lt;hr&gt; {includeComponent('.content/contacts/johnDoe')} {includeComponent('.content/contacts/janeDoe')} &lt;/body&gt;All options how to include components are described in the internal Jazz documentation. 5. Page Build Prepare ScriptUsually web pages do more then just printing variables pebbed up with some stylesheets. Usually it requires server side logic to collect or to enhance the information which shall be displayed. Dachshund components provide the possibility to define a file called prepare.js this one is executed prior to the script which builds the rendition. 'use strict'; const Q = require('q'); const prepare = exports; prepare.handle = function(req, res, pathInfo, resource, component) { const deferred = Q.defer(); // here comes your code which has to call &quot;deferred.resolve()&quot; when it's done // or &quot;deferred.reject(new Error(&quot;&lt;reason&gt;&quot;)) in case there was an error while processing return deferred.promise; };5.1 - Add Prepare ScriptFor our demo page we implement a prepare.js in the path /apps/helloWorld/pageComponents/helloWorld. The comments show how the contacts resource get resolved by RepositorySession which is attached to the request. Based on this resource the child resources get resolved which contain the two user contacts which we've created before. The result is attached to resource.properties to use them in the subsequent executed Jazz template. 'use strict'; const Q = require('q'); const prepare = exports; prepare.handle = function(req, res, pathInfo, resource, component) { const deferred = Q.defer(); // Define the path to the contacts located below '/content/helloDachshund' // which is referenced through the 'resource' variable const pathToContacts = resource.path + '/.content/contacts'; // Resolve the defined path req.session.resolve(pathToContacts).then(function(contactsResource){ // Lookup the child resources of the resolved contacts-resource return contactsResource.getChildResources(); }).then(function(contactChildResources){ // Attach the list of contact resources to the properties to reuse // them in the Jazz template resource.properties.contactResources = contactChildResources; deferred.resolve(); }).fail(deferred.reject); return deferred.promise; };5.2 - Include Contact ResourcesTo make use of the resolved contact resources, open the body.jazz from /apps/helloWorld/pageComponents/helloWorld and change it so that {includeComponent('pathToComponent')} is surrounded by {foreach contactResource in properties.contactResources} to include the contact components dynamically. &lt;body&gt; &lt;h1&gt;{properties.title}&lt;/h1&gt; &lt;p&gt;{properties.description}&lt;/p&gt; &lt;hr&gt; {foreach contactResource in properties.contactResources} {includeComponent(contactResource.path)} {end} &lt;/body&gt; × Search results Close Documentation generated by JSDoc 3.4.0 on Wed Dec 23rd 2015 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
